#pragma once
#include <stddef.h>
#include <malloc.h>
#include <assert.h>
#include <intrin.h>

//#include <stdint.h>
typedef signed char        int8_t;
typedef short              int16_t;
typedef int                int32_t;
typedef long long          int64_t;
typedef unsigned char      uint8_t;
typedef unsigned short     uint16_t;
typedef unsigned int       uint32_t;
typedef unsigned long long uint64_t;

namespace LZ
{
	
#if 0	
	template<typename T>
	class vec
	{//not used new operator
	public:
		vec() : _items(0) { init(0, 16); }
		vec(int size) : _items(0) { init(0, size); }
		vec(vec&& v) : _items(0) { init(v._items, v._size); v._items = 0; }
		~vec() { clean(); }
		T* operator*() { return _items; }
		bool resize(int new_size)
		{
			assert(new_size >= 0);
			T* p = _items = manager.malloc(sizeof(T)*new_size);
			::memcpy_s(p, new_size * sizeof(T), _items, _size);
			return init(p, new_size);
		}
	private:
		bool init(T* p, int size) { clean(); _size = size; _items = p; if (p == 0)_items = manager.malloc(sizeof(T)*_size); return _items != 0; }
		void clean() { if (_items != 0) { manager.free(_items); _items = 0; _size = 0; } }
		T*    _items;
		int _size;
	};
#endif
	
	
	
	namespace utf8util
	{
#if 1
		//add ~8595 bytes
		struct CharInfo { int32_t toUpper, toLower, toTitle, foldCase; };
		struct Chidx { uint8_t idx[128]; };
		const CharInfo d1t[172] = { { 0,0,0,0 },{ 0,32,0,32 },{ -32,0,-32,0 },{ 743,0,743,775 },{ 121,0,121,0 },{ 0,1,0,1 },{ -1,0,-1,0 },{ 0,-199,0,0 },{ -232,0,-232,0 },{ 0,-121,0,-121 },{ -300,0,-300,-268 },{ 195,0,195,0 },{ 0,210,0,210 },{ 0,206,0,206 },{ 0,205,0,205 },{ 0,79,0,79 },{ 0,202,0,202 },{ 0,203,0,203 },{ 0,207,0,207 },{ 97,0,97,0 },{ 0,211,0,211 },{ 0,209,0,209 },{ 163,0,163,0 },{ 0,213,0,213 },{ 130,0,130,0 },{ 0,214,0,214 },{ 0,218,0,218 },{ 0,217,0,217 },{ 0,219,0,219 },{ 56,0,56,0 },{ 0,2,1,2 },{ -1,1,0,1 },{ -2,0,-1,0 },{ -79,0,-79,0 },{ 0,-97,0,-97 },{ 0,-56,0,-56 },{ 0,-130,0,-130 },{ 0,10795,0,10795 },{ 0,-163,0,-163 },{ 0,10792,0,10792 },{ 10815,0,10815,0 },{ 0,-195,0,-195 },{ 0,69,0,69 },{ 0,71,0,71 },{ 10783,0,10783,0 },{ 10780,0,10780,0 },{ 10782,0,10782,0 },{ -210,0,-210,0 },{ -206,0,-206,0 },{ -205,0,-205,0 },{ -202,0,-202,0 },{ -203,0,-203,0 },{ 42319,0,42319,0 },{ 42315,0,42315,0 },{ -207,0,-207,0 },{ 42280,0,42280,0 },{ 42308,0,42308,0 },{ -209,0,-209,0 },{ -211,0,-211,0 },{ 10743,0,10743,0 },{ 42305,0,42305,0 },{ 10749,0,10749,0 },{ -213,0,-213,0 },{ -214,0,-214,0 },{ 10727,0,10727,0 },{ -218,0,-218,0 },{ 42282,0,42282,0 },{ -69,0,-69,0 },{ -217,0,-217,0 },{ -71,0,-71,0 },{ -219,0,-219,0 },{ 42261,0,42261,0 },{ 42258,0,42258,0 },{ 84,0,84,116 },{ 0,116,0,116 },{ 0,38,0,38 },{ 0,37,0,37 },{ 0,64,0,64 },{ 0,63,0,63 },{ -38,0,-38,0 },{ -37,0,-37,0 },{ -31,0,-31,1 },{ -64,0,-64,0 },{ -63,0,-63,0 },{ 0,8,0,8 },{ -62,0,-62,-30 },{ -57,0,-57,-25 },{ -47,0,-47,-15 },{ -54,0,-54,-22 },{ -8,0,-8,0 },{ -86,0,-86,-54 },{ -80,0,-80,-48 },{ 7,0,7,0 },{ -116,0,-116,0 },{ 0,-60,0,-60 },{ -96,0,-96,-64 },{ 0,-7,0,-7 },{ 0,80,0,80 },{ -80,0,-80,0 },{ 0,15,0,15 },{ -15,0,-15,0 },{ 0,48,0,48 },{ -48,0,-48,0 },{ 0,7264,0,7264 },{ 0,38864,0,0 },{ 0,8,0,0 },{ -8,0,-8,-8 },{ -6254,0,-6254,-6222 },{ -6253,0,-6253,-6221 },{ -6244,0,-6244,-6212 },{ -6242,0,-6242,-6210 },{ -6243,0,-6243,-6211 },{ -6236,0,-6236,-6204 },{ -6181,0,-6181,-6180 },{ 35266,0,35266,35267 },{ 35332,0,35332,0 },{ 3814,0,3814,0 },{ -59,0,-59,-58 },{ 0,-7615,0,-7615 },{ 8,0,8,0 },{ 0,-8,0,-8 },{ 74,0,74,0 },{ 86,0,86,0 },{ 100,0,100,0 },{ 128,0,128,0 },{ 112,0,112,0 },{ 126,0,126,0 },{ 9,0,9,0 },{ 0,-74,0,-74 },{ 0,-9,0,-9 },{ -7205,0,-7205,-7173 },{ 0,-86,0,-86 },{ 0,-100,0,-100 },{ 0,-112,0,-112 },{ 0,-128,0,-128 },{ 0,-126,0,-126 },{ 0,-7517,0,-7517 },{ 0,-8383,0,-8383 },{ 0,-8262,0,-8262 },{ 0,28,0,28 },{ -28,0,-28,0 },{ 0,16,0,16 },{ -16,0,-16,0 },{ 0,26,0,26 },{ -26,0,-26,0 },{ 0,-10743,0,-10743 },{ 0,-3814,0,-3814 },{ 0,-10727,0,-10727 },{ -10795,0,-10795,0 },{ -10792,0,-10792,0 },{ 0,-10780,0,-10780 },{ 0,-10749,0,-10749 },{ 0,-10783,0,-10783 },{ 0,-10782,0,-10782 },{ 0,-10815,0,-10815 },{ -7264,0,-7264,0 },{ 0,-35332,0,-35332 },{ 0,-42280,0,-42280 },{ 0,-42308,0,-42308 },{ 0,-42319,0,-42319 },{ 0,-42315,0,-42315 },{ 0,-42305,0,-42305 },{ 0,-42258,0,-42258 },{ 0,-42282,0,-42282 },{ 0,-42261,0,-42261 },{ 0,928,0,928 },{ -928,0,-928,0 },{ -38864,0,-38864,-38864 },{ 0,40,0,40 },{ -40,0,-40,0 },{ 0,34,0,34 },{ -34,0,-34,0 }, };
		const int8_t h1t[979] = { 0,1,2,3,4,5,6,7,8,9,10,11,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,12,-1,-1,-1,-1,-1,13,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,14,15,-1,16,17,18,19,-1,-1,20,21,-1,-1,-1,-1,-1,22,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,23,24,25,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,26,27,28,29,-1,-1,-1,-1,-1,-1,30,31,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,32,-1,-1,-1,-1,-1,-1,-1,-1,-1,33,34,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,35,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,36,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,37 };
		const Chidx a1t[38] = {
		{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,4 },
		{ 5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,7,8,5,6,5,6,5,6,0,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,0,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,9,5,6,5,6,5,6,10 },
		{ 11,12,5,6,5,6,13,5,6,14,14,5,6,0,15,16,17,5,6,14,18,19,20,21,5,6,22,0,20,23,24,25,5,6,5,6,5,6,26,5,6,26,0,0,5,6,26,5,6,27,27,5,6,5,6,28,5,6,0,0,5,6,0,29,0,0,0,0,30,31,32,30,31,32,30,31,32,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,33,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,0,30,31,32,5,6,34,35,5,6,5,6,5,6,5,6 },
		{ 5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,36,0,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,0,0,0,0,0,0,37,5,6,38,39,40,40,5,6,41,42,43,5,6,5,6,5,6,5,6,5,6,44,45,46,47,48,0,49,49,0,50,0,51,52,0,0,0,49,53,0,54,0,55,56,0,57,58,56,59,60,0,0,58,0,61,62,0,0,63,0,0,0,0,0,0,0,64,0,0 },
		{ 65,0,0,65,0,0,0,66,65,67,68,68,69,0,0,0,0,0,70,0,0,0,0,0,0,0,0,0,0,71,72,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,73,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,6,5,6,0,0,5,6,0,0,0,24,24,24,0,74 },
		{ 0,0,0,0,0,0,75,0,76,76,76,0,77,0,78,78,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,79,80,80,80,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,81,2,2,2,2,2,2,2,2,2,82,83,83,84,85,86,0,0,0,87,88,89,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,90,91,92,93,94,95,0,5,6,96,5,6,0,36,36,36 },
		{ 97,97,97,97,97,97,97,97,97,97,97,97,97,97,97,97,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,98,98,98,98,98,98,98,98,98,98,98,98,98,98,98,98,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6 },
		{ 5,6,0,0,0,0,0,0,0,0,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,99,5,6,5,6,5,6,5,6,5,6,5,6,5,6,100,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6 },
		{ 5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,0,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,0,0,0,0,0,0,0,0,0,0,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102 },
		{ 102,102,102,102,102,102,102,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,0,103,0,0,0,0,0,103,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,105,105,105,105,105,105,0,0,106,106,106,106,106,106,0,0 },
		{ 107,108,109,110,110,111,112,113,114,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,115,0,0,0,116,0,0 },
		{ 5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6 },
		{ 5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,0,0,0,0,0,117,0,0,118,0,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6 },
		{ 119,119,119,119,119,119,119,119,120,120,120,120,120,120,120,120,119,119,119,119,119,119,0,0,120,120,120,120,120,120,0,0,119,119,119,119,119,119,119,119,120,120,120,120,120,120,120,120,119,119,119,119,119,119,119,119,120,120,120,120,120,120,120,120,119,119,119,119,119,119,0,0,120,120,120,120,120,120,0,0,0,119,0,119,0,119,0,119,0,120,0,120,0,120,0,120,119,119,119,119,119,119,119,119,120,120,120,120,120,120,120,120,121,121,122,122,122,122,123,123,124,124,125,125,126,126,0,0 },
		{ 119,119,119,119,119,119,119,119,120,120,120,120,120,120,120,120,119,119,119,119,119,119,119,119,120,120,120,120,120,120,120,120,119,119,119,119,119,119,119,119,120,120,120,120,120,120,120,120,119,119,0,127,0,0,0,0,120,120,128,128,129,0,130,0,0,0,0,127,0,0,0,0,131,131,131,131,129,0,0,0,119,119,0,0,0,0,0,0,120,120,132,132,0,0,0,0,119,119,0,0,0,92,0,0,120,120,133,133,96,0,0,0,0,0,0,127,0,0,0,0,134,134,135,135,129,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,136,0,0,0,137,138,0,0,0,0,0,0,139,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,140,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,141,141,141,141,141,141,141,141,141,141,141,141,141,141,141,141,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142 },
		{ 0,0,0,5,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
		{ 101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,0,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,0,5,6,145,146,147,148,149,5,6,5,6,5,6,150,151,152,153,0,5,6,0,5,6,0,0,0,0,0,0,0,154,154 },
		{ 5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,0,0,0,0,0,0,0,5,6,5,6,0,0,0,5,6,0,0,0,0,0,0,0,0,0,0,0,0 },
		{ 155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,0,155,0,0,0,0,0,155,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
		{ 5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,6,5,6,5,6,5,6,5,6,5,6,5,6,0,0,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,0,0,0,0,0,0,0,0,0,5,6,5,6,156,5,6 },
		{ 5,6,5,6,5,6,5,6,0,0,0,5,6,157,0,0,5,6,5,6,0,0,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,158,159,160,161,158,0,162,163,164,165,5,6,5,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,166,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,167,167,167,167,167,167,167,167,167,167,167,167,167,167,167,167 },
		{ 167,167,167,167,167,167,167,167,167,167,167,167,167,167,167,167,167,167,167,167,167,167,167,167,167,167,167,167,167,167,167,167,167,167,167,167,167,167,167,167,167,167,167,167,167,167,167,167,167,167,167,167,167,167,167,167,167,167,167,167,167,167,167,167,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
		{ 168,168,168,168,168,168,168,168,168,168,168,168,168,168,168,168,168,168,168,168,168,168,168,168,168,168,168,168,168,168,168,168,168,168,168,168,168,168,168,168,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,168,168,168,168,168,168,168,168,168,168,168,168,168,168,168,168,168,168,168,168,168,168,168,168,168,168,168,168,168,168,168,168,168,168,168,168,0,0,0,0,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,0,0,0,0 },
		{ 77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,0,0,0,0,0,0,0,0,0,0,0,0,0,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,0,0,0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
		{ 170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
		};
		bool isCased(uint32_t codePoint)
		{
			uint32_t h = codePoint >> 7;
			return h<979 && h1t[h] >= 0 && a1t[h1t[h]].idx[codePoint & 127]>0;
		};
		uint32_t toUpper(uint32_t codePoint)
		{
			uint32_t h = codePoint >> 7;
			if (h<979 && h1t[h] >= 0)
				codePoint += d1t[a1t[h1t[h]].idx[codePoint & 127]].toUpper;
			return codePoint;
		};
		uint32_t toLower(uint32_t codePoint)
		{
			uint32_t h = codePoint >> 7;
			if (h<979 && h1t[h] >= 0)
				codePoint += d1t[a1t[h1t[h]].idx[codePoint & 127]].toLower;
			return codePoint;
		};
		uint32_t toTitle(uint32_t codePoint)
		{
			uint32_t h = codePoint >> 7;
			if (h<979 && h1t[h] >= 0)
				codePoint += d1t[a1t[h1t[h]].idx[codePoint & 127]].toTitle;
			return codePoint;
		};
		uint32_t foldCase(uint32_t codePoint)
		{
			uint32_t h = codePoint >> 7;
			if (h<979 && h1t[h] >= 0)
				codePoint += d1t[a1t[h1t[h]].idx[codePoint & 127]].foldCase;
			return codePoint;
		};
		//add ~3878 bytes
		const uint8_t t1[763] = { 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,1,17,18,19,1,20,21,22,23,24,25,26,27,1,28,29,30,31,31,31,31,31,31,31,31,31,31,32,33,31,31,34,35,31,31,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,36,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,37,1,1,1,1,38,1,39,40,41,42,43,44,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,45,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,1,46,47,1,48,49,50,51,52,53,54,55,56,1,57,58,59,60,61,62,31,31,31,63,64,65,66,67,68,69,70,71,31,72,31,73,74,31,31,1,1,1,75,76,77,31,31,31,31,31,31,31,31,31,31,1,1,1,1,78,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,1,1,79,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,1,1,80,81,31,31,31,82,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,83,1,1,84,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,1,85,86,31,31,31,31,31,31,31,31,31,87,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,88,89,31,90,91,92,93,31,31,94,31,31,31,31,31,95,31,31,31,31,31,31,31,96,97,31,31,31,31,98,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,99,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,100,101,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,102,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,103,31,31,31,31,31,31,31,31,31,31,31,31,1,1,104 };
		const uint8_t t21[1696] = { 0,0,0,1,2,3,2,4,0,0,5,6,7,8,7,8,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,9,10,11,0,12,12,12,12,12,12,12,13,14,7,15,7,7,7,7,16,7,7,7,7,7,7,7,7,17,7,7,7,7,7,7,7,7,7,7,2,7,18,2,7,19,20,12,21,22,7,4,23,0,24,7,7,25,12,26,27,7,7,7,7,7,28,29,30,0,31,7,12,32,7,7,7,7,7,33,34,35,7,25,36,7,37,38,0,7,39,4,0,0,0,7,40,0,41,42,12,43,7,7,44,12,45,46,2,47,48,49,50,51,52,46,53,54,48,49,55,56,57,58,59,60,15,49,61,62,63,46,64,65,48,49,61,66,67,46,68,69,70,71,72,73,74,58,0,75,76,49,77,78,79,46,0,80,76,49,81,78,82,46,83,75,76,7,84,85,86,46,87,88,89,7,90,91,92,58,93,2,7,7,94,95,1,0,0,96,97,98,99,100,101,0,0,63,102,1,103,104,7,105,20,106,107,12,108,109,0,0,0,7,7,25,110,1,111,112,113,114,115,7,7,116,7,7,117,7,7,7,7,118,119,7,7,118,7,7,120,121,8,7,7,7,121,7,7,7,122,123,124,7,0,7,7,7,7,7,125,2,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,126,7,2,4,7,7,7,7,127,128,129,130,7,130,7,131,129,132,7,7,7,133,12,134,1,0,135,1,7,7,7,7,7,19,7,7,136,7,7,7,7,137,7,138,139,139,58,7,140,141,7,7,142,7,143,24,0,0,7,144,7,7,7,145,12,146,1,1,147,115,0,0,0,0,148,7,7,133,149,1,150,151,152,7,153,35,7,7,33,151,7,7,133,154,155,35,7,140,128,0,0,0,0,156,157,158,7,7,7,7,7,7,7,7,7,7,7,7,12,12,12,159,7,125,7,7,125,160,7,140,7,7,7,161,162,163,105,162,0,0,0,164,165,166,0,167,0,105,0,0,0,108,168,165,169,170,171,172,173,0,7,7,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,7,138,7,7,138,7,7,7,7,7,7,7,7,174,175,7,7,116,7,7,7,176,164,7,177,178,178,178,178,12,12,179,0,180,181,2,7,7,7,7,182,2,7,7,7,7,117,183,7,138,2,7,7,7,7,138,0,7,4,0,0,0,7,7,7,7,7,7,7,7,7,7,7,7,137,0,0,0,0,7,7,7,7,7,7,7,7,7,7,7,7,7,7,4,0,7,7,7,7,7,7,7,7,105,0,0,0,0,7,7,140,105,7,184,0,7,7,185,186,7,187,7,7,7,7,7,124,0,188,189,7,7,7,7,7,190,7,138,19,0,0,0,188,191,7,192,0,7,7,7,193,194,7,7,133,195,1,12,196,35,7,197,7,198,151,7,105,43,7,7,199,200,1,201,202,7,7,203,204,205,1,7,206,7,7,7,207,208,209,25,210,211,212,178,7,7,117,137,7,7,7,7,7,7,7,213,1,7,7,7,7,7,7,7,7,7,7,193,7,214,7,7,142,7,7,7,7,7,7,140,7,7,7,7,7,7,143,0,0,177,215,49,216,217,7,7,7,7,7,7,10,0,218,7,7,7,7,7,140,0,7,7,7,7,189,7,7,19,0,0,142,12,0,12,219,220,0,0,221,7,7,7,7,7,7,7,105,0,1,2,3,2,4,222,7,7,7,7,138,223,224,0,0,225,7,8,226,140,140,0,0,7,7,7,7,7,7,7,4,0,0,0,0,7,7,7,141,0,0,0,0,0,0,0,227,0,0,0,0,0,0,0,0,7,105,7,7,7,63,165,0,7,7,228,7,4,7,7,229,7,140,7,7,230,231,0,0,7,7,7,7,7,7,7,7,7,140,1,7,7,230,7,142,7,7,19,7,7,7,193,0,0,0,0,0,0,0,0,0,7,7,7,177,7,137,19,0,0,0,0,0,0,0,0,0,232,7,7,233,7,137,7,177,7,138,0,0,0,0,7,234,7,137,7,143,0,0,0,0,7,7,7,235,0,0,0,0,236,237,7,238,0,0,7,105,7,105,0,0,104,7,239,0,7,7,7,137,7,137,7,23,7,10,0,0,0,0,0,0,7,7,7,7,128,0,0,0,7,7,7,23,7,7,7,23,152,7,7,240,204,0,58,164,152,7,7,24,0,7,128,1,152,7,198,241,0,7,7,242,152,7,7,199,243,244,0,0,7,15,245,246,0,0,0,0,247,248,128,7,7,185,24,1,249,48,49,61,66,250,251,252,0,0,0,0,0,0,0,0,7,7,7,253,254,1,0,0,7,7,7,12,255,1,0,0,0,0,0,0,0,0,0,0,7,7,185,0,165,1,0,0,7,7,7,12,2,1,0,0,7,7,25,154,1,0,0,0,7,3,139,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,7,7,7,1,4,5,7,7,6,7,8,7,7,9,1,0,0,7,7,7,128,49,7,185,10,63,1,0,189,7,11,107,204,0,0,0,0,12,7,7,13,14,1,0,0,0,0,0,0,0,0,0,0,7,7,7,7,7,7,7,7,7,143,0,0,0,0,0,0,7,7,7,7,7,7,138,0,7,7,7,7,7,7,7,7,7,7,7,7,193,0,0,0,0,0,0,0,0,0,0,0,7,7,138,0,0,0,0,0,0,0,0,0,0,0,0,0,7,7,7,7,177,0,0,0,0,0,0,0,0,0,0,0,7,7,7,128,7,138,1,0,0,0,0,0,0,7,140,252,7,7,7,204,193,1,218,15,7,0,0,0,0,0,0,0,7,7,7,7,141,16,12,17,164,152,0,0,0,0,10,0,7,7,7,7,7,7,7,7,7,7,7,7,7,7,105,0,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,23,7,138,0,0,0,0,0,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,142,7,7,7,7,7,7,4,105,128,18,0,0,0,0,0,0,0,0,0,0,0,0,19,20,21,0,22,0,0,0,0,0,0,0,0,0,23,0,0,0,0,0,0,0,0,0,0,0,7,7,7,7,7,221,7,7,7,129,24,25,26,7,7,7,27,28,7,29,30,76,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,31,7,76,117,7,117,7,221,7,221,138,7,138,7,49,7,49,7,32,12,12,12,12,12,12,33,12,12,108,34,166,150,20,0,0,0,0,0,10,35,36,0,0,0,0,0,0,0,0,0,0,0,0,0,7,7,7,7,7,7,7,7,7,7,7,7,141,204,0,0,7,7,7,7,37,1,0,0,0,0,0,0,0,0,0,0,26,7,38,39,40,41,42,43,44,142,45,142,0,0,0,0,7,7,7,7,7,7,7,7,7,7,7,7,7,177,0,0,7,7,7,141,7,7,7,7,7,7,7,7,7,7,7,7,7,140,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,10,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,63,0,7,140,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,0 };
		const uint32_t t22[53] = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1058816,2147483650,34079033,25,0,0,8388608,160,0,33554432,1050048,1776640,268436480,458888,1048576,1533,0,0,0 };
		const uint32_t ac2[302] = { 0,699050,4294967292,2151677951,4194303,3145728,3181568,4294967295,4294918143,4294963215,15,855639039,2863311530,3488674815,4081037312,4294967247,4294955007,4293962383,802815,65535,2863311528,2326440618,35368,63,2796202,2864709631,4027230890,4294967294,2192223487,4204969642,3287984810,4294967291,4230654634,2863312895,14,4294617770,3149738,2864361471,179022762,11272191,268432383,2863311360,2863311498,4294967210,2930769919,4294945451,2863308975,3288333483,4294967235,4294180863,2920280115,981631658,3472916480,50331663,3225418920,2718907635,176324650,872153096,2863308800,3066,3489660072,2920283379,176851626,3,2863398912,3288333480,176325290,3472924672,12,4030725344,4080799731,4030661568,2685403135,178429994,32771,4093639850,4294967283,2886729727,178430634,4139008,4093639851,2920283391,805316608,60,2931818495,983737002,3221274368,4293918720,4294966432,4293935103,218103759,2149597183,2863276714,160,2796283,715833343,204718908,4294770432,4243639548,243968763,178926591,4278889130,655360,2684913664,4294770687,67108863,2885657258,2863180458,44739242,8192,3937053354,2952441855,4205493934,4294966955,3131746991,178956970,201379839,4282384383,267649023,267599871,1073680371,4294905843,2822766591,2863136768,10,268374015,3288334335,4030726143,262143,4093640703,687,175,163,2863311615,184598698,176160768,3932159,4095,1073741823,11184810,268435455,1023,16777215,1048575,11190271,715828223,2192222890,49152,4294966954,16776874,2860515328,170,4294967274,4205488811,43690,4228557482,2863311402,4227771050,704175,2861214378,3435986943,872412159,67105776,16773375,2147483648,2,512,3221225484,2863310856,4293967920,268373247,4294128384,4279238655,806353920,3217032191,250,3221291007,16383,1073692671,64512,2863661052,67047420,4293410815,4294966272,16427690,3221225471,3400182272,2952790015,4294950912,4294967280,4291035135,4290768879,43711,255,4294967290,2730,213975034,178958335,2863316991,2863311551,3221225474,4294966271,1073392298,2863398911,10922,184549311,4205854719,2952707758,59,264241152,11248,1073496060,16380,170568383,4290789375,3959488448,872366079,4294964175,4294967232,640,2818572288,4294964223,4294963200,4293984240,66125808,4244635647,3477078015,134217728,4227858432,2797567,4294902015,4092,4294119423,3271806975,3903,4026597375,2852137131,4294769919,2150236415,11263,2863333375,2863309482,12479,44041214,54176426,2868903935,536914602,3488825343,3489660927,3288333482,4227891203,44736687,682,2863311871,4188842,53162,2863270570,184483840,770,2819620863,3221225472,4293569195,716876479,32768,4289374891,2863657215,2863278762,2863311520,4291772415,2317363883,47786,4227923967,2863311531,715827882,672137215,2819270656,2860515370,11184170,178257920,672,4093393968,4241489919,4294966527,4232040447,4093637631,1070596095,4293932031,4294905855,2701131583,2860526250,2048,2860690090,2794122,2796287,4294755132,13434687,4241276976,3435971388,4282368828,872218431,4291821567,4291820796 };
		
		//unicode IDStart and 0x24 ($) and 0x5F (_)
		bool isIDStart(uint32_t c)
		{
			if (c == 0x24 || c == 0x5F) return true;
			uint32_t i = c >> 8; if (i > 4351)return false;if (i == 3585)i = 105;else if (i > 762)i = 31;else i = t1[i];
			c = (i << 8) + (c & 255); i = c >> 4;i = t21[i] | (((t22[i >> 5] >> (i & 31)) & 1) << 8);c &= 15;
			c = (ac2[i] >> (c << 1)) & 1;
			return c == 1;
		}
		//unicode IDContinue and 0x24 ($) and 0x5F (_) and 0x200C and 0x200D
		bool isIDContinue(uint32_t c)
		{
			if (c == 0x24 || c == 0x5F || c == 0x200C || c == 0x200D) return true;
			uint32_t i = c >> 8; if (i > 4351)return false;if (i == 3585)i = 105;else if (i > 762)i = 31;else i = t1[i];
			c = (i << 8) + (c & 255); i = c >> 4;i = t21[i] | (((t22[i >> 5] >> (i & 31)) & 1) << 8);c &= 15;
			c = (ac2[i] >> (c << 1)) & 2;
			return c == 2;
			//add: 0x24, 0x200C, 0x200D
		}
		bool isSpace(uint32_t c)
		{
			//WhiteSpace
			//0x9,0xB,0xC,0x20,0xA0,0xFEFF,0x1680,0x2000..0x200A,0x202F,0x205F,0x3000
			//LineTerminator
			//0xA,0xD,0x2028,0x2029
			return
				c == 0x9 || c == 0xA || c == 0xB || c == 0xC || c == 0xD || c == 0x20 || c == 0xA0 ||
				c == 0x2028 || c == 0x2029 || c == 0xFEFF || c == 0x1680 || (c >= 0x2000 && c <= 0x200A) || c == 0x202F || c == 0x205F || c == 0x3000;
		}

#endif

		//sources:
		//https://en.wikipedia.org/wiki/UTF-8
		//https://github.com/voku/portable-utf8/tree/master/tests
		//https://github.com/htacg/tidy-html5/blob/next/src/utf8.c
		//https://github.com/JuliaLang/utf8proc/blob/master/utf8proc.c
		//https://github.com/ww898/utf-cpp/blob/master/test/utf_converters_test.cpp
		//https://github.com/tchwork/utf8/blob/master/tests/Utf8/Utf8StrcasecmpTest.php
		//https://github.com/svaarala/duktape/blob/master/src-input/duk_unicode_support.c
		//
		//other info
		//https://dxr.mozilla.org/mozilla-central/source/js/src/vm/Unicode.h
		//https://dxr.mozilla.org/mozilla-central/source/js/src/vm/Unicode.cpp
		//https://dxr.mozilla.org/mozilla-central/source/js/src/vm/CharacterEncoding.cpp
		//https://dxr.mozilla.org/mozilla-central/source/intl/icu/source/common/unicode/uchar.h
		//


		//NotAChar:       0xFFFF or bytes:0xEF,0xBF,0xBF
		//ByteOrderMark:  0xFEFF or bytes:0xEF,0xBB,0xBF
		//ByteOrderMark2: 0xFFFE or bytes:0xEF,0xBF,0xBE

		//Legal UTF - 8 byte sequences
		//http://www.unicode.org/versions/corrigendum1.html
		//	Code point          1st byte    2nd byte    3rd byte    4th byte
		//	----------          --------    --------    --------    --------
		//	U+0000 .. U+007F     00..7F
		//	U+0080 .. U+07FF     C2..DF      80..BF
		//	U+0800 .. U+0FFF     E0          A0..BF      80..BF
		//	U+1000 .. U+FFFF     E1..EF      80..BF      80..BF
		//
		//excluding
		//[ U+D800 .. U+DFFF     ED          A0..BF      80..BF ]
		//
		//	U+10000.. U+3FFFF    F0          90..BF      80..BF      80..BF
		//	U+40000.. U+FFFFF    F1..F3      80..BF      80..BF      80..BF
		//	U+100000..U+10FFFF   F4          80..8F      80..BF      80..BF

		//UTF16
		//  U+D800 .. U+DFFF forbidden
		//http://www.unicode.org/faq/utf_bom.html


		//error codes:
#define RESULT_OK                     0
#define ERROR_DST_LENGTH              2
#define ERROR_UTF8_DECODE_RANGE       3
#define ERROR_UTF8_ENCODE_RANGE       4
#define ERROR_UTF8_CONTINUATION_BYTE  5
#define ERROR_UTF16_DECODE_RANGE      6
#define ERROR_UTF16_ENCODE_RANGE      7
#define ERROR_UTF16_CONTINUATION_WORD 8
#define ERROR_UTF32_DECODE_RANGE      9
#define ERROR_UTF32_ENCODE_RANGE      10
//replacement_char -> "�" 0xFFFD utf8 -> [EF,BF,BD]
#define R_CHAR        0xFFFD
#define R_CHAR_UTF8_0 0xEF
#define R_CHAR_UTF8_1 0xBF
#define R_CHAR_UTF8_2 0xBD
//options on invalid chars
#define OPT_REPLACE_INVALID   0
#define OPT_SKIP_INVALID      1
#define OPT_BREAKON_INVALID   2


		struct validation_info
		{
			uint8_t status;
			uint32_t nerrors;
			uint32_t length8;
			uint32_t length16;
			uint32_t length32;
			void* src_next;
		};


		//checking UTF8 string for validity
		//also counting the number uint16 and uint32 data elements nedeed to convert utf8 to utf16 and utf32
		//src_length - src length, uint8_t data elements
		//option     - OPT_*, for OPT_BREAKON_INVALID return validity status on first error
		//vi         - ptr to validation_info struct, or nullptr
		//return RESULT_OK on success or ERROR_UTF8_* on error occurs
		uint8_t utf8_validation(uint8_t* src, uint32_t src_length, uint8_t option, validation_info* vi)
		{
			uint8_t ret = RESULT_OK;
			uint32_t ncount32 = 0, ncount16 = 0, nerrors = 0, len = src_length;
			while (src_length > 0)
			{
				uint8_t c = *src++;
				if (c < 0x80) { src_length -= 1; goto on_ok; }
				else if (c < 0xC2 || c > 0xF4) { src_length -= 1; goto on_error_range; }
				else if (c < 0xE0)
				{
					if (src_length < 2) { src_length -= 1; goto on_error_range; }
					c = *src++;if ((c & 0xC0) != 0x80) { src_length -= 1; goto on_error_continuation; }
					src_length -= 2;
					goto on_ok;
				}
				else if (c < 0xF0)
				{
					if (src_length < 3) { src_length -= 1; goto on_error_range; }
					if (c == 0xE0) { c = *src++; if (c < 0xA0 || c > 0xBF) { src_length -= 1; goto on_error_continuation; } }
					else if (c == 0xED) { c = *src++; if (c < 0x80 || c > 0x9F) { src_length -= 1; goto on_error_continuation; } }
					else { c = *src++; if ((c & 0xC0) != 0x80) { src_length -= 1; goto on_error_continuation; } }
					c = *src++; if ((c & 0xC0) != 0x80) { src_length -= 2; goto on_error_continuation; }
					src_length -= 3;
					goto on_ok;
				}
				else
				{
					if (src_length < 4) { src_length -= 1; goto on_error_range; }
					if (c == 0xF0) { c = *src++; if (c < 0x90 || c > 0xBF) { src_length -= 1; goto on_error_continuation; } }
					else if (c < 0xF4) { c = *src++; if ((c & 0xC0) != 0x80) { src_length -= 1; goto on_error_continuation; } }
					else { c = *src++; if (c < 0x80 || c > 0x8F) { src_length -= 1; goto on_error_continuation; } }
					c = *src++; if ((c & 0xC0) != 0x80) { src_length -= 2; goto on_error_continuation; }
					c = *src++; if ((c & 0xC0) != 0x80) { src_length -= 3; goto on_error_continuation; }
					src_length -= 4; ncount16++;
					goto on_ok;
				}
			on_error_continuation:
				nerrors++;
				src--;
				if (option == OPT_BREAKON_INVALID) { ret = ERROR_UTF8_CONTINUATION_BYTE; break; }
				goto on_ok;
			on_error_range:
				nerrors++;
				if (option == OPT_BREAKON_INVALID) { ret = ERROR_UTF8_DECODE_RANGE; src--; break; }
			on_ok:
				ncount32++;
			}
			if (vi != nullptr)
			{
				ncount16 += ncount32;
				if (option == OPT_SKIP_INVALID) { ncount16 -= nerrors; ncount32 -= nerrors; }
				vi->length8 = len - src_length;
				vi->length16 = ncount16;
				vi->length32 = ncount32;
				vi->nerrors = nerrors;
				vi->src_next = src;
				vi->status = ret;
			}
			return ret;
		}

		//checking UTF16 string for validity
		//also counting the number uint8 and uint32 data elements nedeed to convert utf16 to utf8 and utf32
		//src_length - src length, uint16_t data elements
		//option     - OPT_*, for OPT_BREAKON_INVALID return validity status on first error
		//vi         - ptr to validation_info struct, or nullptr
		//return RESULT_OK on success or ERROR_UTF16_* on error occurs
		uint8_t utf16_validation(uint16_t* src, uint32_t src_length, uint8_t option, validation_info* vi)
		{
			uint8_t ret = RESULT_OK;
			uint16_t c, *src_end = src + src_length;
			uint32_t ncount32 = 0, ncount8 = 0, nerrors = 0;
			while (src < src_end)
			{
				c = *src++;
				if (c < 0x0080) { ncount8 += 1; }
				else if (c < 0x0800) { ncount8 += 2; }
				else if (c < 0xD800 || c > 0xDFFF) { ncount8 += 3; }
				else if (c < 0xDC00)
				{
					if (src == src_end || *src < 0xDC00 || *src > 0xDFFF)
					{
						nerrors++;
						if (option == OPT_BREAKON_INVALID) { ret = ERROR_UTF16_CONTINUATION_WORD; break; }
					}
					else { ncount8 += 4; src++; }
				}
				else
				{
					nerrors++;
					if (option == OPT_BREAKON_INVALID) { ret = ERROR_UTF16_ENCODE_RANGE; src--; break; }
				}
				ncount32++;
			}
			if (vi != nullptr)
			{
				if (option == OPT_SKIP_INVALID) { ncount32 -= nerrors; }
				else { ncount8 += nerrors * 3; }
				vi->length8 = ncount8;
				vi->length16 = src_length - uint32_t(src_end - src);
				vi->length32 = ncount32;
				vi->nerrors = nerrors;
				vi->src_next = src;
				vi->status = ret;
			}
			return ret;
		}




		//counting the number uint16 data elements nedeed to convert utf8 to utf16
		//src_length - src length, uint8_t elements
		//unsafe, for valid utf8, but fast
		//uint32_t utf8to16_length_unsafe(uint8_t* src, uint32_t src_length)
		//{
		//	uint32_t i = 0, ncount = 0;
		//	while (i < src_length)
		//	{
		//		uint8_t c = src[i];
		//		if (c < 0x80) { i += 1; }
		//		else if (c < 0xE0) { i += 2; }
		//		else if (c < 0xF0) { i += 3; }
		//		else { i += 4; ncount++; }
		//		ncount++;
		//	}
		//	return ncount;
		//}
		uint32_t utf8to16_length_unsafe(uint8_t* src, uint32_t src_length)
		{
			uint32_t i = 0, ncount = 0;
			while (i < src_length)
			{
				int8_t c = src[i];
				if (c >= 0) { i++; }          // 0 ... 127
				else if (c < -32) { i += 2; } //-64...-33
				else if (c < -16) { i += 3; } //-32...-17
				else { i += 4; ncount++; }    //-16...-1
				ncount++;
			}
			return ncount;
		}
		//counting the number uint16 data elements nedeed to convert utf8 to utf16
		//src_length - src length, uint8_t elements
		//option     - OPT_*
		uint32_t utf8to16_length(uint8_t* src, uint32_t src_length, uint8_t option)
		{
			uint32_t ncount = 0, nerrors = 0;
			while (src_length > 0)
			{
				uint8_t c = *src++;
				if (c < 0x80) { src_length -= 1; goto on_ok; }
				else if (c < 0xC2 || c > 0xF4) { src_length -= 1; goto on_error_range; }
				else if (c < 0xE0)
				{
					if (src_length < 2) { src_length -= 1; goto on_error_range; }
					c = *src++;if ((c & 0xC0) != 0x80) { src_length -= 1; goto on_error_continuation; }
					src_length -= 2;
					goto on_ok;
				}
				else if (c < 0xF0)
				{
					if (src_length < 3) { src_length -= 1; goto on_error_range; }
					if (c == 0xE0) { c = *src++; if (c < 0xA0 || c > 0xBF) { src_length -= 1; goto on_error_continuation; } }
					else if (c == 0xED) { c = *src++; if (c < 0x80 || c > 0x9F) { src_length -= 1; goto on_error_continuation; } }
					else { c = *src++; if ((c & 0xC0) != 0x80) { src_length -= 1; goto on_error_continuation; } }
					c = *src++; if ((c & 0xC0) != 0x80) { src_length -= 2; goto on_error_continuation; }
					src_length -= 3;
					goto on_ok;
				}
				else
				{
					if (src_length < 4) { src_length -= 1; goto on_error_range; }
					if (c == 0xF0) { c = *src++; if (c < 0x90 || c > 0xBF) { src_length -= 1; goto on_error_continuation; } }
					else if (c < 0xF4) { c = *src++; if ((c & 0xC0) != 0x80) { src_length -= 1; goto on_error_continuation; } }
					else { c = *src++; if (c < 0x80 || c > 0x8F) { src_length -= 1; goto on_error_continuation; } }
					c = *src++; if ((c & 0xC0) != 0x80) { src_length -= 2; goto on_error_continuation; }
					c = *src++; if ((c & 0xC0) != 0x80) { src_length -= 3; goto on_error_continuation; }
					src_length -= 4; ncount++;
					goto on_ok;
				}
			on_error_continuation:
				src--;
			on_error_range:
				nerrors++;
				if (option == OPT_BREAKON_INVALID) { return ncount; }
			on_ok:
				ncount++;
			}
			if (option == OPT_SKIP_INVALID) { return ncount - nerrors; }
			return ncount;
		}

		//counting the number uint8 data elements nedeed to convert utf16 to utf8
		//src_length - src length, uint16_t elements
		//option     - OPT_*
		uint32_t utf16to8_length(uint16_t* src, uint32_t src_length, uint8_t option)
		{
			uint16_t *src_end = src + src_length;
			uint32_t ncount = 0;
			while (src < src_end)
			{
				uint16_t c = *src++;
				if (c < 0x0080) { ncount += 1; }
				else if (c < 0x0800) { ncount += 2; }
				else if (c < 0xD800 || c > 0xDFFF) { ncount += 3; }
				else if (c < 0xDC00)
				{
					if (src == src_end || *src < 0xDC00 || *src > 0xDFFF) { if (option == OPT_BREAKON_INVALID) { return ncount; } if (option == OPT_REPLACE_INVALID) { ncount += 3; } }
					else { ncount += 4; src++; }
				}
				else { if (option == OPT_BREAKON_INVALID) { return ncount; } if (option == OPT_REPLACE_INVALID) { ncount += 3; } }
			}
			return ncount;
		}
		//counting the number uint8 data elements nedeed to convert utf16 to utf8
		//src_length - src length, uint16_t elements
		//unsafe, for valid utf16, but fast
#define utf16to8_length_unsafe(src, src_length) utf16to8_length((src), (src_length), OPT_REPLACE_INVALID)

		//counting the number uint32 data elements nedeed to convert utf8 to utf32
		//src_length - src length, uint8_t elements
		//unsafe, for valid utf8, but fast
		uint32_t utf8to32_length_unsafe(uint8_t* src, uint32_t src_length)
		{
			uint32_t i = 0, ncount = 0;
			while (i < src_length)
			{
				uint8_t c = src[i];
				if (c < 0x80) { i += 1; }
				else if (c < 0xE0) { i += 2; }
				else if (c == 0xE0) { i += 3; }
				else { i += 4; }
				ncount++;
			}
			return ncount;
		}
		//uint32_t utf8to32_length_unsafe_(uint8_t* src, uint32_t src_length)
		//{
		//	uint32_t i = 0, ncount = 0;
		//	while (i < src_length)
		//	{
		//		int8_t c = src[i];
		//		if (c >= 0) { i += 1; }       // 0 ... 127
		//		else if (c < -32) { i += 2; } //-64...-33
		//		else if (c < -16) { i += 3; } //-32...-17
		//		else { i += 4; }              //-16...-1
		//		ncount++;
		//	}
		//	return ncount;
		//}
		//counting the number uint32 data elements nedeed to convert utf8 to utf32
		//src_length - src length, uint8_t elements
		//option     - OPT_*
		uint32_t utf8to32_length(uint8_t* src, uint32_t src_length, uint8_t option)
		{
			uint32_t ncount = 0, nerrors = 0;
			while (src_length > 0)
			{
				uint8_t c = *src++;
				if (c < 0x80) { src_length -= 1; goto on_ok; }
				else if (c < 0xC2 || c > 0xF4) { src_length -= 1; goto on_error_range; }
				else if (c < 0xE0)
				{
					if (src_length < 2) { src_length -= 1; goto on_error_range; }
					c = *src++;if ((c & 0xC0) != 0x80) { src_length -= 1; goto on_error_continuation; }
					src_length -= 2;
					goto on_ok;
				}
				else if (c < 0xF0)
				{
					if (src_length < 3) { src_length -= 1; goto on_error_range; }
					if (c == 0xE0) { c = *src++; if (c < 0xA0 || c > 0xBF) { src_length -= 1; goto on_error_continuation; } }
					else if (c == 0xED) { c = *src++; if (c < 0x80 || c > 0x9F) { src_length -= 1; goto on_error_continuation; } }
					else { c = *src++; if ((c & 0xC0) != 0x80) { src_length -= 1; goto on_error_continuation; } }
					c = *src++; if ((c & 0xC0) != 0x80) { src_length -= 2; goto on_error_continuation; }
					src_length -= 3;
					goto on_ok;
				}
				else
				{
					if (src_length < 4) { src_length -= 1; goto on_error_range; }
					if (c == 0xF0) { c = *src++; if (c < 0x90 || c > 0xBF) { src_length -= 1; goto on_error_continuation; } }
					else if (c == 0xF4) { c = *src++; if (c < 0x80 || c > 0x8F) { src_length -= 1; goto on_error_continuation; } }
					else { c = *src++; if ((c & 0xC0) != 0x80) { src_length -= 1; goto on_error_continuation; } }
					c = *src++; if ((c & 0xC0) != 0x80) { src_length -= 2; goto on_error_continuation; }
					c = *src++; if ((c & 0xC0) != 0x80) { src_length -= 3; goto on_error_continuation; }
					src_length -= 4;
					goto on_ok;
				}
			on_error_continuation:
				src--;
			on_error_range:
				nerrors++;
				if (option == OPT_BREAKON_INVALID) { return ncount; }
			on_ok:
				ncount++;
			}
			if (option == OPT_SKIP_INVALID) { return ncount - nerrors; }
			return ncount;
		}
		//counting the number uint8 nedeed to convert utf32 to utf8
		//src_length - src length, uint32_t elements
		//option     - OPT_*
		uint32_t utf32to8_length(uint32_t* src, uint32_t src_length, uint8_t option)
		{
			uint32_t ncount = 0;
			uint32_t c, *src_end = src + src_length;
			while (src < src_end)
			{
				c = *src++;
				if (c < 0x80) { ncount++; }
				else if (c < 0x0800) { ncount += 2; }
				else if (c < 0xD800) { ncount += 3; }
				else if (c > 0xDFFF && c < 0x110000)
				{
					if (c < 0x10000) { ncount += 3; }
					else { ncount += 4; }
				}
				else { if (option == OPT_BREAKON_INVALID) { return ncount; } if (option == OPT_REPLACE_INVALID) { ncount += 3; } }
			}
			return ncount;
		}
		//counting the number uint8 nedeed to convert utf32 to utf8
		//src_length - src length, uint32_t elements
		//unsafe, for valid utf32, but fast
#define utf32to8_length_unsafe(src, src_length) utf32to8_length((src), (src_length), OPT_REPLACE_INVALID)

#define UTF8_NEXT(i, src, src_length, cp, option) \
	{ \
		uint8_t __c = src[i++]; \
		if (__c < 0x80) { cp = __c; goto on_ok; } \
		else if (__c < 0xC2 || __c > 0xF4) { goto on_error_range; } \
		else if (__c < 0xE0) \
		{ \
			if (i >= src_length) { goto on_error_range; } \
			cp = uint32_t(__c & 0x1F) << 6; \
			__c = src[i];if ((__c & 0xC0) != 0x80) { goto on_error_continuation; } \
			cp |= (__c & 0x3F); i++; \
			goto on_ok; \
		} \
		else if (__c < 0xF0) \
		{ \
			if (i + 1 >= src_length) { goto on_error_range; } \
			cp = uint32_t(__c & 0x0F) << 12; \
			if (__c == 0xE0) { __c = src[i]; if (__c < 0xA0 || __c > 0xBF) { goto on_error_continuation; } } \
			else if (__c == 0xED) { __c = src[i]; if (__c < 0x80 || __c > 0x9F) { goto on_error_continuation; } } \
			else { __c = src[i]; if ((__c & 0xC0) != 0x80) { goto on_error_continuation; } } \
			cp |= uint32_t(__c & 0x3F) << 6; i++; \
			__c = src[i]; if ((__c & 0xC0) != 0x80) { goto on_error_continuation; } \
			cp |= (__c & 0x3F); i++; \
			goto on_ok; \
		} \
		else /*if (__c <= 0xF4)*/ \
		{ \
			if (i + 2 >= src_length) { goto on_error_range; } \
			cp = uint32_t(__c & 0x07) << 18; \
			if (__c == 0xF0) { __c = src[i]; if (__c < 0x90 || __c > 0xBF) { goto on_error_continuation; } } \
			else if (__c < 0xF4) { __c = src[i]; if ((__c & 0xC0) != 0x80) { goto on_error_continuation; } } \
			else { __c = src[i]; if (__c < 0x80 || __c > 0x8F) { goto on_error_continuation; } } \
			cp |= uint32_t(__c & 0x3F) << 12; i++; \
			__c = src[i]; if ((__c & 0xC0) != 0x80) { goto on_error_continuation; } \
			cp |= uint32_t(__c & 0x3F) << 6; i++; \
			__c = src[i]; if ((__c & 0xC0) != 0x80) { goto on_error_continuation; } \
			cp |= (__c & 0x3F); i++; \
			goto on_ok; \
		} \
	} \
on_error_range: \
	if (option == OPT_BREAKON_INVALID) { return ERROR_UTF8_DECODE_RANGE; } \
on_error_continuation: \
	if (option == OPT_BREAKON_INVALID) { return ERROR_UTF8_CONTINUATION_BYTE; } \
	if (option == OPT_SKIP_INVALID) { continue; } cp = R_CHAR; \
on_ok:

#define UTF8_ENCODE(cp, dst, dst_length, option) \
	if (cp < 0x80) \
	{ \
		if (dst_length < 1) { return ERROR_DST_LENGTH; } \
		*dst++ = static_cast<uint8_t>(cp); dst_length--; \
	} \
	else if (cp < 0x800) \
	{ \
		if (dst_length < 2) { return ERROR_DST_LENGTH; } \
		*dst++ = static_cast<uint8_t>(0xC0 | (cp >> 6)); \
		*dst++ = static_cast<uint8_t>(0x80 | (cp & 0x3F)); \
		dst_length -= 2; \
	} \
	else if (cp < 0xD800) \
	{ \
		if (dst_length < 3) { return ERROR_DST_LENGTH; } \
		*dst++ = static_cast<uint8_t>(0xE0 | (cp >> 12)); \
		*dst++ = static_cast<uint8_t>(0x80 | ((cp >> 6) & 0x3F)); \
		*dst++ = static_cast<uint8_t>(0x80 | (cp & 0x3F)); \
		dst_length -= 3; \
	} \
	else if (cp > 0xDFFF && cp < 0x110000) \
	{ \
		if (cp < 0x10000) \
		{ \
			if (dst_length < 3) { return ERROR_DST_LENGTH; } \
			*dst++ = static_cast<uint8_t>(0xE0 | (cp >> 12)); \
			*dst++ = static_cast<uint8_t>(0x80 | ((cp >> 6) & 0x3F)); \
			*dst++ = static_cast<uint8_t>(0x80 | (cp & 0x3F)); \
			dst_length -= 3; \
		} \
		else /*if (cp < 0x110000)*/ \
		{ \
			if (dst_length < 4) { return ERROR_DST_LENGTH; } \
			*dst++ = static_cast<uint8_t>(0xF0 | (cp >> 18)); \
			*dst++ = static_cast<uint8_t>(0x80 | ((cp >> 12) & 0x3F)); \
			*dst++ = static_cast<uint8_t>(0x80 | ((cp >> 6) & 0x3F)); \
			*dst++ = static_cast<uint8_t>(0x80 | (cp & 0x3F)); \
			dst_length -= 4; \
		} \
	} \
	else \
	{ \
		/*on error out of range*/ \
		if (option == OPT_BREAKON_INVALID) { return ERROR_UTF8_ENCODE_RANGE; } \
		if (option == OPT_REPLACE_INVALID) \
		{ \
			if (dst_length < 3) { return ERROR_DST_LENGTH; } \
			*dst++ = R_CHAR_UTF8_0; \
			*dst++ = R_CHAR_UTF8_1; \
			*dst++ = R_CHAR_UTF8_2; \
			dst_length -= 3; \
		} \
	}

#define UTF8_DECODE(cp, src, src_length, option) \
	{ \
		uint8_t __c = *src++; \
		if (__c < 0x80) { cp = uint32_t(__c); src_length--; goto on_ok;} \
		else if (__c < 0xC2 || __c > 0xF4) { goto on_error_range;} \
		else if (__c < 0xE0) \
		{ \
			if (src_length < 2) { goto on_error_range; } \
			cp = uint32_t(__c & 0x1F) << 6; \
			__c = *src++;if ((__c & 0xC0) != 0x80) { src_length -= 1; goto on_error_continuation; } \
			cp |= uint32_t(__c & 0x3F); \
			src_length -= 2; \
			goto on_ok; \
		} \
		else if (__c < 0xF0) \
		{ \
			if (src_length < 3) { goto on_error_range; } \
			cp = uint32_t(__c & 0x0F) << 12; \
			if( __c == 0xE0) { __c = *src++; if (__c < 0xA0 || __c > 0xBF) { src_length -= 1; goto on_error_continuation; } } \
			else if (__c == 0xED) { __c = *src++; if (__c < 0x80 || __c > 0x9F) { src_length -= 1; goto on_error_continuation; } } \
			else { __c = *src++; if ((__c & 0xC0) != 0x80) { src_length -= 1; goto on_error_continuation; } } \
			cp |= uint32_t(__c & 0x3F) << 6; \
			__c = *src++; if ((__c & 0xC0) != 0x80) { src_length -= 2; goto on_error_continuation; } \
			cp |= uint32_t(__c & 0x3F); \
			src_length -= 3; \
			goto on_ok; \
		} \
		else if (__c <= 0xF4) \
		{ \
			if (src_length < 4) { goto on_error_range; } \
			cp = uint32_t(__c & 0x07) << 18; \
			if(__c == 0xF0) { __c = *src++; if (__c < 0x90 || __c > 0xBF) { src_length -= 1; goto on_error_continuation; } } \
			else if(__c < 0xF4) { __c = *src++; if ((__c & 0xC0) != 0x80) { src_length -= 1; goto on_error_continuation; } } \
			else { __c = *src++; if (__c < 0x80 || __c > 0x8F) { src_length -= 1; goto on_error_continuation; } } \
			cp |= uint32_t(__c & 0x3F) << 12; \
			__c = *src++; if ((__c & 0xC0) != 0x80) { src_length -= 2; goto on_error_continuation; } \
			cp |= uint32_t(__c & 0x3F) << 6; \
			__c = *src++; if ((__c & 0xC0) != 0x80) { src_length -= 3; goto on_error_continuation; } \
			cp |= uint32_t(__c & 0x3F); \
			src_length -= 4; \
			goto on_ok; \
		} \
	} \
on_error_range: \
		if (option == OPT_BREAKON_INVALID) { return ERROR_UTF8_DECODE_RANGE; } src_length--; if(option == OPT_SKIP_INVALID) { continue; } cp = R_CHAR; goto on_ok; \
on_error_continuation: \
		if (option == OPT_BREAKON_INVALID) { return ERROR_UTF8_CONTINUATION_BYTE; } src--; if(option == OPT_SKIP_INVALID) { continue; } cp = R_CHAR; \
on_ok:

#define UTF16_NEXT(i, src, src_length, c, option) \
	c = src[i++]; \
	/*if (need_swap) c = static_cast<uint16_t>(((c & 0xFF) << 8) | (c >> 8));*/ \
	if ((c & 0xF800) == 0xD800) \
	{ \
		if (c < 0xDC00 && i < src_length) \
		{ \
			uint32_t __c1 = src[i];if (__c1 < 0xDC00 || __c1 > 0xDFFF) { if (option == OPT_BREAKON_INVALID)return ERROR_UTF16_CONTINUATION_WORD;if (option == OPT_SKIP_INVALID)continue; c = R_CHAR; }\
			else { c = (c << 10) + __c1 + 0xFCA02400UL; i++; } \
		} \
		else { if (option == OPT_BREAKON_INVALID)return ERROR_UTF16_DECODE_RANGE;if (option == OPT_SKIP_INVALID)continue; c = R_CHAR; } \
	}

#define UTF16_DECODE(cp, src, src_length, option) \
	{ \
		uint32_t __c = *src++; \
		/*if (need_swap) c = static_cast<uint16_t>(((c & 0xFF) << 8) | (c >> 8));*/ \
		if (__c < 0xD800 || __c > 0xDFFF) { cp = uint32_t(__c); src_length--; goto on_ok_16; } \
		else if (__c < 0xDC00) \
		{ \
			if (src_length < 2) { goto on_error_range_16; }\
			/*codepoint in ranges U+D800..U+DBFF and U+DC00..U+DFFF is reserved for utf16 surrogate pairs*/ \
			cp = uint32_t(__c & 0x3FF) << 10; \
			__c = *src++; if (__c < 0xDC00 || __c > 0xDFFF) { src_length -= 1; goto on_error_continuation_16; } \
			cp |= uint32_t(__c & 0x3FF); \
			cp += 0x10000; \
			src_length -= 2; \
			goto on_ok_16; \
		} \
	} \
on_error_range_16: \
	if (option == OPT_BREAKON_INVALID) { return ERROR_UTF16_DECODE_RANGE; } src_length--; if(option == OPT_SKIP_INVALID) { continue; } cp = R_CHAR; goto on_ok_16; \
on_error_continuation_16: \
	if (option == OPT_BREAKON_INVALID) { return ERROR_UTF16_CONTINUATION_WORD; } src--; if(option == OPT_SKIP_INVALID) { continue; } cp = R_CHAR; \
on_ok_16:

#define UTF16_ENCODE(cp, dst, dst_length, option) \
	if (dst_length == 0) { return ERROR_DST_LENGTH; } \
	if (cp < 0xD800) { *dst++ = uint16_t(cp); dst_length--; } \
	else if (cp < 0xE000) \
	{ \
		/*codepoint in ranges U+D800..U+DBFF and U+DC00..U+DFFF is reserved for utf16 surrogate pairs */ \
		if (option == OPT_BREAKON_INVALID) { return ERROR_UTF16_ENCODE_RANGE; } \
		if (option == OPT_REPLACE_INVALID) { *dst++ = R_CHAR; dst_length--; } \
	} \
	else if (cp < 0x10000) \
	{ \
		*dst++ = uint16_t(cp); dst_length--; \
	} \
	else if (cp < 0x110000) \
	{ \
		if(dst_length < 2) { return ERROR_DST_LENGTH; } \
		/*U+010000..U+10FFFF*/ \
		cp -= 0x10000; \
		*dst++ = uint16_t(0xD800 | (cp >> 10));   /*D800..DBFF*/ \
		*dst++ = uint16_t(0xDC00 | (cp & 0x3FF)); /*DC00..DFFF*/ \
		dst_length -= 2; \
	} \
	else \
	{ \
		/*on error emit replacement codepoint*/ \
		if (option == OPT_BREAKON_INVALID) { return ERROR_UTF16_ENCODE_RANGE; } \
		if (option == OPT_REPLACE_INVALID) { *dst++ = R_CHAR; dst_length--; } \
	}

#define UTF32_NEXT(i, src, src_length, cp, option) \
	cp = src[i++]; \
	/*if (need_swap) cp = ((cp & 0xFF) << 24) | ((cp & 0xFF00) << 8) | ((cp & 0xFF0000) >> 8) | (cp >> 24);*/ \
	if ((cp & 0xF800) == 0xD800 || cp > 0x10FFFF) { if (option == OPT_BREAKON_INVALID) { return ERROR_UTF32_DECODE_RANGE; } if (option == OPT_SKIP_INVALID) { continue; } cp = R_CHAR; }

#define UTF32_DECODE(cp, src, src_length, option) \
	cp = *src++; src_length--; \
	/*if (need_swap) cp = ((cp & 0xFF) << 24) | ((cp & 0xFF00) << 8) | ((cp & 0xFF0000) >> 8) | (cp >> 24);*/ \
	if ((cp & 0xF800) == 0xD800 || cp > 0x10FFFF) { if (option == OPT_BREAKON_INVALID) { return ERROR_UTF32_DECODE_RANGE; } if (option == OPT_SKIP_INVALID) { continue; } cp = R_CHAR; }

#define UTF32_ENCODE(cp, dst, dst_length, option) \
	if (dst_length == 0) { return ERROR_DST_LENGTH; } \
	if ((cp & 0xF800) == 0xD800 || cp > 0x10FFFF) { if (option == OPT_BREAKON_INVALID) { return ERROR_UTF32_ENCODE_RANGE; } if (option == OPT_SKIP_INVALID) { continue; } cp = R_CHAR; } \
	*dst++ = cp; dst_length--;

		//convert utf8 string to utf32 string
		//src_length - src string length, uint8_t elements
		//dst_length - dst string length, uint32_t elements
		uint8_t utf8to32(uint8_t* src, uint32_t src_length, uint32_t* dst, uint32_t dst_length, uint8_t option)
		{
			uint32_t i = 0, cp;
			//test BOM: 0xEF,0xBB,0xBF and skip it
			//if (src_length > 2 && src[0] == 0xEF && src[1] == 0xBB && src[2] == 0xBF) { src += 3; src_length -= 3; }
			while (i < src_length)
			{
				UTF8_NEXT(i, src, src_length, cp, option);
				UTF32_ENCODE(cp, dst, dst_length, OPT_SKIP_INVALID);
			}
			return RESULT_OK;
		}
		//convert utf32 string to utf8 string
		//src_length - src string length, uint32_t elements
		//dst_length - dst string length, uint8_t elements
		uint8_t utf32to8(uint32_t* src, uint32_t src_length, uint8_t* dst, uint32_t dst_length, uint8_t option)
		{
			uint32_t i = 0, cp;
			//test BOM: 0x0000FEFF and skip it
			//if (src_length > 0 && src[0] == 0x0000FEFF) { src++; src_length--; }
			while (i < src_length)
			{
				UTF32_NEXT(i, src, src_length, cp, option);
				UTF8_ENCODE(cp, dst, dst_length, OPT_SKIP_INVALID);
			}
			return RESULT_OK;
		}
		//convert utf8 string to utf16 string
		//src_length - src string length, uint8_t elements
		//dst_length - dst string length, uint16_t elements
		uint8_t utf8to16(uint8_t* src, uint32_t src_length, uint16_t* dst, uint32_t dst_length, uint8_t option)
		{
			uint32_t i = 0, cp;
			//test BOM: 0xEF,0xBB,0xBF and skip it
			//if (src_length > 2 && src[0] == 0xEF && src[1] == 0xBB && src[2] == 0xBF) { src += 3; src_length -= 3; }
			while (i < src_length)
			{
				UTF8_NEXT(i, src, src_length, cp, option);
				UTF16_ENCODE(cp, dst, dst_length, OPT_SKIP_INVALID);
			}
			return RESULT_OK;
		}
		//convert utf16 string to utf8 string
		//src_length - src string length, uint16_t elements
		//dst_length - dst string length, uint8_t elements
		uint8_t utf16to8(uint16_t* src, uint32_t src_length, uint8_t* dst, uint32_t dst_length, uint8_t option)
		{
			uint32_t i = 0, cp;
			//test BOM: 0xFEFF and skip it
			//if (src_length > 0 && src[0] == 0xFEFF) { src++; src_length--; }
			while (i < src_length)
			{
				UTF16_NEXT(i, src, src_length, cp, option);
				UTF8_ENCODE(cp, dst, dst_length, OPT_SKIP_INVALID);
			}
			return RESULT_OK;
		}

		/*
		//counting the number of unicode codepoints in the utf8 string
		//src_length - src length, uint8_t elements
		//ошибка: более трёх подряд continuation байт считаются одним символом
		uint32_t utf8_codepoints(uint8_t* src, uint32_t src_length)
		{
		uint32_t cp, ncount = 0, *src_i32, *src_end;
		if (src_length == 0) return 0;
		//align to 4 byte
		cp = reinterpret_cast<uint32_t>(src) & 3;
		if (cp != 0)
		{
		if (cp < 2 && src_length > 0) { if ((((*src++) ^ 0x80) & 0xC0) != 0) ncount++; src_length--; }
		if (cp < 3 && src_length > 0) { if ((((*src++) ^ 0x80) & 0xC0) != 0) ncount++; src_length--; }
		if (cp < 4 && src_length > 0) { if ((((*src++) ^ 0x80) & 0xC0) != 0) ncount++; src_length--; }
		}
		if (src_length == 0)return ncount;
		//load as int32_t and count non continuation bytes
		src_i32 = reinterpret_cast<uint32_t*>(src);
		src_end = reinterpret_cast<uint32_t*>(src + (src_length & 0xFFFFFFFC));
		while (src_i32 < src_end)
		{
		cp = *src_i32++;
		cp ^= 0x80808080;
		if ((cp & 0xC0000000) != 0)ncount++;
		if ((cp & 0x00C00000) != 0)ncount++;
		if ((cp & 0x0000C000) != 0)ncount++;
		if ((cp & 0x000000C0) != 0)ncount++;
		}
		//count last bytes
		cp = src_length & 3;
		if (cp != 0)
		{
		src = reinterpret_cast<uint8_t*>(src_end);
		if (cp > 0 && (((*src++) ^ 0x80) & 0xC0) != 0)ncount++;
		if (cp > 1 && (((*src++) ^ 0x80) & 0xC0) != 0)ncount++;
		if (cp > 2 && (((*src++) ^ 0x80) & 0xC0) != 0)ncount++;
		}
		return ncount;
		}
		//counting the number of unicode codepoints in the utf16 string
		//src_length - src length, uint16_t elements
		uint32_t utf16_codepoints(uint16_t* src, uint32_t src_length)
		{
		uint16_t *src_end = src + src_length;
		uint32_t ncount = src_length;
		while (src < src_end)
		{
		if (((*src++) & 0xFC00) == 0xDC00) { ncount--; }
		}
		return ncount;
		}
		//counting the number of unicode codepoints in the utf32 string
		//src_length - src length, uint32_t elements
		uint32_t utf32_codepoints(uint32_t* src, uint32_t src_length)
		{
		//if(size == 0)//for null terminated data
		//	while (*data++ > 0) size++;
		return src_length;
		}
		*/







	}//end namespace utf8util



	namespace memory
	{
		//LogBase2 ~ 26 sec (DeBruijn)
		//int LogBase2_32(uint32_t n) { static const int table[32] = {0,9,1,10,13,21,2,29,11,14,16,18,22,25,3,30,8,12,20,28,15,17,24,7,19,27,23,6,26,5,4,31}; n |= n >> 1; n |= n >> 2; n |= n >> 4; n |= n >> 8; n |= n >> 16; return n ? table[(n * 0x07C4ACDDU) >> 27] : -1; };
		//inline int LogBase2_64(uint64_t n) { static const int table[64] = {0,58,1,59,47,53,2,60,39,48,27,54,33,42,3,61,51,37,40,49,18,28,20,55,30,34,11,43,14,22,4,62,57,46,52,38,26,32,41,50,36,17,19,29,10,13,21,56,45,25,31,35,16,9,12,44,24,15,8,23,7,6,5,63}; n |= n >> 1; n |= n >> 2; n |= n >> 4; n |= n >> 8; n |= n >> 16; n |= n >> 32; return n ? table[(n * 0x03F6EAF2CD271461ULL) >> 58] : -1; };
		//ilog2 ~ 13 sec
		//inline int ilog2_32(uint32_t x) { unsigned long index; return _BitScanForward(&index, x) ? index : -1; };
		//inline int ilog2_64(uint64_t x) { register unsigned long index; return _BitScanForward64(&index, x) ? index : -1; };
		//ilog2_generic ~ 24 sec
		//inline int ilog2_generic_64(register uint64_t x)
		//{
		//	register uint64_t r = 0;
		//	if (x >= 1LL << 32) { x >>= 32; r |= 32; }
		//	if (x >= 1LL << 16) { x >>= 16; r |= 16; }
		//	if (x >= 1LL << 8) { x >>= 8; r |= 8; }
		//	if (x >= 1LL << 4) { x >>= 4; r |= 4; }
		//	if (x >= 1LL << 2) { x >>= 2; r |= 2; }
		//	if (x >= 1LL << 1) r |= 1;
		//	return x ? (int)r : -1;
		//};
		//fast_log2 ~ 9 sec
		inline int fast_log2(double x) { return (reinterpret_cast<uint64_t&>(x) >> 52) - 1023; };
		inline int fast_log2i(double x){ union { double d; int32_t i[2]; }v = { x }; return (v.i[1] >> 20) - 1023;};
		//inline int fast_log2(register double x) { return ((reinterpret_cast<uint64_t&>(x) >> 52) & 2047) - 1023; };
		//inline int float_log2(float x) { return ((*reinterpret_cast<uint32_t*>(&x) >> 23) & 255) - 127; };

		//--------------------------------------------------------------
		//                TLSF-like memory pool
		//--------------------------------------------------------------
		// Sources:
		// https://github.com/mattconte/tlsf
		// http://www.gii.upv.es/tlsf/main/docs
		// https://code.google.com/archive/p/compcache/wikis/xvMalloc.wiki
		//
		//Для 32 и 64 битных систем:
		//1. Для выделенных блоков заголовок занимает            4 байт (только поле size).
		//   Для освобождённых блоков заголовок занимает        16 байт.
		//2. Адрес выделяемого блока выравнивается            до 4 байт.
		//3. Размеры выделяемых блоков выравниваются          до 4 байт.
		//4. Минимальный размер блока равен                     16 байт (min capacity = 12 байт).
		//5. Размер fti_table для хранения списков unused blocks
		//   (при fti_bits = 5)        равен 828 эл.= 828*4 = 3312 байт.
		//6. Максимальный размер блока не может превышать величины
		//   (при fti_bits = 5)                 = pool_size - 3424 байт.
		//7. Свободные блоки с размерами < fti_first_max*data_alignment,
		//   (при fti_bits = 5) fti_first_max*data_alignment = 256 байт,
		//   попадают в fti_table в соответствии с диапазонами:
		//       |16-19|20-23|...|254-255|       <= с шагом 4 байта,
		//   далее шаг удваивается с пропорциональным удвоением диапазона:
		//       |256-263|264-271|...|504-511|   <= с шагом 8 байт,
		//       |512-527|528-543|...|1008-1023| <= с шагом 16 байт,
		//       |1024-1055|...                  <= с шагом 32 байт,
		//       и т.д.
		//
		//VERSION 2.1
		// - on 32-bit systems, reduce all data_header fields to 4 bytes
		//   on 64-bit systems, reduce all data_header fields to 4 bytes
		// - ptr replaced to int32_t offsets (4 bytes)
		// - added malloc_aligned()
		// - added realloc()
		//
		//VERSION 2.0
		// - on 32-bit systems, reduce all data_header fields to 4 bytes
		//   on 64-bit systems, reduce all data_header fields to 8 bytes
		//
		//
		//
		//Data structure:
		//1) structure of data block 1 after malloc space 1
		//|--------------------------------------------------------------------|---------------------------------
		//|  size   |                    used space 1                          |  size   |   used space 2 ...
		//|---------|----------------------------------------------------------|---------|-----------------------
		//| header1 |ptr1                                                      | header2 |ptr2
		//|--------------------------------------------------------------------|---------------------------------
		//|                      data block 1                                  |     data block 2
		//|--------------------------------------------------------------------|---------------------------------
		//
		//2) structure of data block 1 after free space 1
		//|-----------------------------------------------------------|------------------------------------------
		//|  size   | next_unused  | prev_unused |   unused space 1   |  prev  |  size   |   used space 2 ...
		//|--------------------------------------|--------------------|------------------|-----------------------
		//|             header1                  |                    |     header2      |ptr2
		//|-----------------------------------------------------------|------------------------------------------
		//|                      data block 1                         |              data block 2
		//|-----------------------------------------------------------|------------------------------------------

		//Возможные улучшения (TODO):
		//Для малых размеров 32 бит для поля size избыточно.
		//  Тогда для хранения размера можно использовать столько байт, сколько требуется.
		//  В этом случае для определения 1,2,3 или 4 байт можно использовать 2 и 3 биты size.
		//  Из-за выравниваения по 4 байта адреса блока и его размера, возможно, что
		//  эта мера не будет эффективной. Минимально всё равно будет 4 байта.
		//Можно не вычислять fti, если вместе с size хранить его fti.
		//Можно все указатели сделать uint32_t*, вместо uint8_t*.


		//set default memory allocation functions
		struct allocator
		{
			static inline void* malloc(size_t size) { return ::_aligned_malloc(size, 1); };
			static inline void* malloc_aligned(size_t size, size_t align) { return ::_aligned_malloc(size, align); };
			static inline void* realloc(void* p, size_t size) { return ::_aligned_realloc(p, size, 1); }
			static inline void  free(void* ptr) { return ::_aligned_free(ptr); };
			static inline size_t msize(void* ptr) { return ::_aligned_msize(ptr, 1, 0); };
		};

#define data_alignment       4
#define data_alignment_bits  2
#define data_alignment_mask  (~3UL)
#define data_header_size     4
#define data_header_bytes    16
#define data_header_offset   8
#define default_pool_size    0x40000UL
#define busy_bit             1
#define prev_busy_bit        2
#define fti_bits             3
#define fti_first_max        (1UL<<(fti_bits + 1))
#define fti_table_n          (((32 - data_alignment_bits - fti_bits + 1) << fti_bits) - (data_header_bytes / data_alignment))
#define sti_table_n          ((fti_table_n + 31)/32)
#define page_header_bytes    ((fti_table_n + sti_table_n + 1)*4)
#define cast_data_header(p, offset)  reinterpret_cast<data_header*>(reinterpret_cast<uint8_t*>(p) + (offset))
//cast and offset by 4 byte words
#define cast_data_header_32bit(p, offs)  reinterpret_cast<data_header*>(reinterpret_cast<uint32_t*>(p) + (offs))
#define offs_data_header_32bit(p, p_to)  int32_t(reinterpret_cast<uint32_t*>(p_to) - reinterpret_cast<uint32_t*>(p))
//use external allocator functions on failure
#undef USE_EXTERNAL_ALLOCATOR_ON_FAILURE
#undef USE_FTI_FIELD_IN_HEADER

		struct data_header
		{
			 int32_t prev;         //offset to previuos data header  (if prev_block_busy_bit == 0)
			uint32_t size;         //memory block size, 0 bit is busy_bit, 1 bit is prev_block_busy_bit
			 int32_t next_unused;  //offset to next unused block     (if busy_bit == 0)
			 int32_t prev_unused;  //offset to previous unused block (if busy_bit == 0)
#if defined(USE_FTI_FIELD_IN_HEADER)
			uint32_t fti;          //fti value for size field        (if size > data_header_bytes)
#endif
		};
		struct page_header
		{
			uint32_t fti_table[fti_table_n]; //first table  - offsets to first unused block
			uint32_t sti_table[sti_table_n]; //second table - bitmap of used cells in fti_table
			uint32_t memory_in_use;          //memory in use, bytes
		};

		class page_manager
		{
		public:
			page_manager()
			{
				_pool_ptr = 0;_pool_size = 0;
			}
			page_manager(void* pool, uint32_t bytes)
			{
				_pool_ptr = 0;_pool_size = 0; create(pool, bytes);
			}
			~page_manager()
			{
				destroy();
			}
			bool create(void* pool, uint32_t bytes)
			{
				if (_pool_ptr != 0) destroy();
				if (bytes == 0) bytes = default_pool_size;
				if (pool == 0) pool = allocator::malloc(bytes);
				return create_with_pool(pool, bytes);
			}
			bool destroy()
			{
				if (_pool_ptr != 0) allocator::free(_pool_ptr);
				_pool_ptr = 0; _pool_size = 0;
				return true;
			}
			bool reinit()
			{
				if (_pool_ptr != 0)
					return create_with_pool(_pool_ptr, _pool_size);
				return false;
			}
		private:
			bool create_with_pool(void* pool, uint32_t size)
			{//create memory pool
				_pool_ptr = 0;
				_pool_size = 0;
				if (pool == 0
					|| size < (page_header_bytes + data_header_size + data_header_bytes)
					|| ((reinterpret_cast<size_t>(pool) | data_alignment) & (data_alignment - 1)) != 0) return false;
				_pool_ptr = static_cast<page_header*>(pool);
				_pool_size = size & data_alignment_mask;
				//init page header
				::memset(_pool_ptr, 0, page_header_bytes);
				_pool_ptr->memory_in_use = page_header_bytes + data_header_size;
				//init first data_header
				data_header* p = cast_data_header(_pool_ptr, page_header_bytes + data_header_size - data_header_offset);
				p->size = _pool_size - page_header_bytes - data_header_size;
				p->size |= prev_busy_bit;
				//init last data_header at end pool
				data_header* p_last = cast_data_header(p, p->size & data_alignment_mask);
				p_last->size = 0 | busy_bit;
				link_unused_block(p);
				return true;
			};
			inline uint32_t* get_first_unused_block_by_size(uint32_t size)
			{
				assert(size >= data_header_bytes && "size must be greater than or equal to data_header_bytes");
				uint32_t fti = size >> data_alignment_bits;
				if (fti >= fti_first_max)
				{
					register union { double d; uint32_t i[2]; }v = { (double)fti };
					v.i[1] = (v.i[1] >> 20) - 1023 - fti_bits;
					fti = (v.i[1] << fti_bits) + (fti >> v.i[1]);
				}
				fti -= data_header_bytes / data_alignment;
				return &_pool_ptr->fti_table[fti];
			};
			void unlink_unused_block(data_header* p)
			{
				if (p->prev_unused)
				{
					if (p->next_unused) cast_data_header_32bit(p, p->prev_unused)->next_unused += p->next_unused;
					else cast_data_header_32bit(p, p->prev_unused)->next_unused = 0;
				}
				if (p->next_unused)
				{
					if (p->prev_unused) cast_data_header_32bit(p, p->next_unused)->prev_unused += p->prev_unused;
					else cast_data_header_32bit(p, p->next_unused)->prev_unused = 0;
				}
				if (p->prev_unused == 0)
				{
				#if defined(USE_FTI_FIELD_IN_HEADER)
					//restore fti value
					assert((data_header_bytes >> data_alignment_bits) <= fti_first_max);
					uint32_t fti = (p->size >> data_alignment_bits);
					if (fti > fti_first_max) fti = p->fti; else fti -= data_header_bytes / data_alignment;
					uint32_t *pu = &_pool_ptr->fti_table[fti];
					assert(pu == get_first_unused_block_by_size(p->size));
				#else
					uint32_t *pu = get_first_unused_block_by_size(p->size);
				#endif
					if (p->next_unused) *pu = offs_data_header_32bit(_pool_ptr, cast_data_header_32bit(p, p->next_unused));
					else
					{
						*pu = 0;
						_pool_ptr->sti_table[(pu - _pool_ptr->fti_table) >> 5] &= ~(0x80000000UL >> ((pu - _pool_ptr->fti_table) & 31));
					}
				}
			};
			void link_unused_block(data_header* p)
			{
				p->next_unused = 0;
				p->prev_unused = 0;
				p->size &= ~busy_bit;//clear busy_bit
				//update prev field and prev_busy_bit of next data_header
				data_header *p_next = cast_data_header(p, p->size & data_alignment_mask);
				p_next->size &= ~prev_busy_bit;
				p_next->prev = offs_data_header_32bit(p_next, p);
				//link to list
				uint32_t *pu = get_first_unused_block_by_size(p->size);
			#if defined(USE_FTI_FIELD_IN_HEADER)
				//store fti value
				if ((p->size >> data_alignment_bits) > fti_first_max){ p->fti = offs_data_header_32bit(_pool_ptr->fti_table, pu); }
			#endif
				if (*pu)
				{
					p->next_unused = offs_data_header_32bit(p, cast_data_header_32bit(_pool_ptr, *pu));
					cast_data_header_32bit(_pool_ptr, *pu)->prev_unused = -p->next_unused;
				}
				*pu = offs_data_header_32bit(_pool_ptr, p);
				_pool_ptr->sti_table[(pu - _pool_ptr->fti_table) >> 5] |= 0x80000000UL >> ((pu - _pool_ptr->fti_table) & 31);
			};
			data_header* find_unused_block(uint32_t size)
			{
				data_header *p = 0;
				uint32_t
					*pu = get_first_unused_block_by_size(size),
					 m = 0xFFFFFFFFUL >> ((pu - _pool_ptr->fti_table) & 31),
					*pbit = &_pool_ptr->sti_table[(pu - _pool_ptr->fti_table) >> 5],
					*pbit_end = &_pool_ptr->sti_table[sti_table_n];
				while (1)
				{
					if (p == 0)
					{
						m &= (*pbit);
						if (m == 0)
						{
							pbit++; while (pbit < pbit_end && *pbit == 0) pbit++;
							if (pbit >= pbit_end) return 0;
							m = *pbit;
						}
						register union { double d; int32_t i[2]; }v = { (double)m };
						m = 31 + 1023 - (v.i[1] >> 20);
						pu = &_pool_ptr->fti_table[m + ((pbit - _pool_ptr->sti_table) << 5)];
						m++; m = (m < 32) ? 0xFFFFFFFFUL >> m : 0;//shr workaround for 5 bit mask
						p = cast_data_header_32bit(_pool_ptr, *pu);

						assert(pu < &_pool_ptr->fti_table[fti_table_n] && "pu must not point outside of the table");
					}
					if (p->size >= size) break;
					p = p->next_unused == 0 ? 0 : cast_data_header_32bit(p, p->next_unused);
				}
				return p;
			};
			//split unused block
#define split_block(p, required_size, sub_size) \
			{ \
				uint32_t size = p->size & data_alignment_mask; \
				if (size < (required_size) + data_header_bytes) \
				{ \
					/*update busy_bit*/ \
					p->size |= busy_bit; \
					/*update prev_busy_bit of next data block*/ \
					cast_data_header(p, size)->size |= prev_busy_bit; \
				} \
				else \
				{ \
					/*set new data block*/ \
					p->size = (required_size) | (p->size & prev_busy_bit) | busy_bit; \
					/*set new unused block*/ \
					data_header* p_right = cast_data_header(p, (required_size)); \
					p_right->size = size - (required_size); \
					p_right->size |= prev_busy_bit; \
					/*link unused block*/ \
					link_unused_block(p_right); \
				} \
				/*update memory_in_use*/ \
				_pool_ptr->memory_in_use += (p->size & data_alignment_mask) - (sub_size); \
			}
		public:
			size_t get_used_size()
			{
				assert(_pool_ptr > 0 && "pointer must not be 0");
				return _pool_ptr->memory_in_use;
			};
			size_t get_free_size()
			{
				assert(_pool_ptr > 0 && "pointer must not be 0");
				return _pool_size - _pool_ptr->memory_in_use;
			};
			size_t msize(void* ptr)
			{//return capacity (greater than or equal to the size) of used data block, 0 otherwise
				assert(_pool_ptr > 0 && "pointer must not be 0");
			#if defined(USE_EXTERNAL_ALLOCATOR_ON_FAILURE)
				if (ptr < _pool_ptr || ptr >= cast_data_header(_pool_ptr, _pool_size)) { return allocator::msize(ptr); }
			#else
				assert(ptr > _pool_ptr && ptr < cast_data_header(_pool_ptr, _pool_size) && "ptr must be in the pool");
			#endif
				data_header *p = cast_data_header(ptr, -int(data_header_offset));
				return (p->size & busy_bit) == busy_bit ? (p->size & data_alignment_mask) - data_header_size : 0;
			};
			void* malloc(uint32_t size)
			{
				assert(_pool_ptr > 0 && size > 0 && "pointer and size must not be 0");
				if (size == 0) return 0;
				//alignment of size
				uint32_t size_aligned = (size + data_header_size + data_alignment - 1) & data_alignment_mask;
				if (size_aligned < data_header_bytes) size_aligned = data_header_bytes;
				//find unused block
				data_header* p = find_unused_block(size_aligned);
			#if defined(USE_EXTERNAL_ALLOCATOR_ON_FAILURE)
				if (p == 0) { return allocator::malloc(size); }
			#else
				if (p == 0) { return 0; }
			#endif
				//unlink unused block
				unlink_unused_block(p);
				//split unused block
				split_block(p, size_aligned, 0);
				return cast_data_header(p, data_header_offset);
			};
			void free(void* ptr)
			{
				assert(_pool_ptr > 0 && "pointer must not be 0");
			#if defined(USE_EXTERNAL_ALLOCATOR_ON_FAILURE)
				if (ptr < _pool_ptr || ptr >= cast_data_header(_pool_ptr, _pool_size)) { allocator::free(ptr); return; }
			#else
				assert(ptr > _pool_ptr && ptr < cast_data_header(_pool_ptr, _pool_size) && "ptr must be in the pool");
			#endif
				data_header *p = cast_data_header(ptr, -int(data_header_offset));
				
				assert((p->size & busy_bit) == busy_bit && "memory block must be busy");

				//далее предполагается, что слева и справа от data block
				//может быть только один unused block

				uint32_t unused = p->size & data_alignment_mask;
				//update memory_in_use
				_pool_ptr->memory_in_use -= unused;

				data_header *p_next = cast_data_header(p, unused), *p_prev;
				if ((p_next->size & busy_bit) == 0)
				{
					unlink_unused_block(p_next);
					unused += p_next->size & data_alignment_mask;
				}
				if ((p->size & prev_busy_bit) == 0)
				{
					p_prev = cast_data_header_32bit(p, p->prev);
					unlink_unused_block(p_prev);
					unused += p_prev->size & data_alignment_mask;
					p = p_prev;
				}
				p->size = unused | (p->size & prev_busy_bit);
				//link new unused block
				link_unused_block(p);
			};
			void* malloc_aligned(uint32_t size, uint32_t align)
			{
				if (align == 0 || (data_alignment % align) == 0)return malloc(size);
				assert((align & ~data_alignment_mask) == 0 && "align should be a multiple of data_alignment");

				//allocate free memory block with an additional minimum block size bytes
				void *ptr = malloc(size + data_header_bytes + align - 1);
			#if defined(USE_EXTERNAL_ALLOCATOR_ON_FAILURE)
				if (ptr == 0) { return allocator::malloc_aligned(size, align); }
			#else
				if (ptr == 0) { return 0; }
			#endif				
				//align ptr
				data_header *p = cast_data_header(ptr, -int(data_header_offset)), *p_new;			
				size_t addr = (size_t)ptr + data_header_bytes + align - 1; addr -= addr % align; ptr = (void*)addr;
				p_new = cast_data_header(ptr, -int(data_header_offset));
				p_new->size = offs_data_header_32bit(p_new, cast_data_header(p, p->size & data_alignment_mask)) << 2;
				p_new->size |= prev_busy_bit | busy_bit;
				
				//release leading free block back to the pool
				p->size -= p_new->size & data_alignment_mask;
				free(cast_data_header(p, data_header_offset));
				return ptr;
			}
			void* realloc(void* ptr, uint32_t size)
			{
			#if defined(USE_EXTERNAL_ALLOCATOR_ON_FAILURE)
				if (ptr < _pool_ptr || ptr >= cast_data_header(_pool_ptr, _pool_size)) { return allocator::realloc(ptr, size); }
			#else
				assert(ptr > _pool_ptr && ptr < cast_data_header(_pool_ptr, _pool_size) && "ptr must be in the pool");
			#endif
				//treated as malloc
				if (ptr == 0) { return malloc(size); }
				//treated as free
				if (size == 0) { free(ptr); return 0; }
				//realloc
				//alignment of size
				uint32_t required_size, cur_size, unused_left, unused_right, join_size;
				required_size = (size + data_header_size + data_alignment - 1) & data_alignment_mask;
				if (required_size < data_header_bytes) required_size = data_header_bytes;
				data_header *p = cast_data_header(ptr, -int(data_header_offset)), *p_right, *p_left;
				cur_size = p->size & data_alignment_mask;

				//there is no need to move the data block
				//test for current block capacity enough
				if (required_size <= cur_size)
				{
					//split unused block
					split_block(p, required_size, cur_size);
					return ptr;
				}
				//test the right data block for growth and if necessary, increase the size
				p_right = cast_data_header(p, cur_size);
				unused_right = (p_right->size & busy_bit) == busy_bit ? 0 : p_right->size & data_alignment_mask;
				join_size = cur_size + unused_right;
				if (join_size >= required_size)
				{
					unlink_unused_block(p_right);
					p->size += unused_right;
					//split unused block
					split_block(p, required_size, cur_size);
					return ptr;
				}
				//there is a need to move the data block
				//test the right data block for growth and if necessary, increase the size
				unused_left = (p->size & prev_busy_bit) == prev_busy_bit ? 0 : (-p->prev) << 2;
				join_size += unused_left;
				if (join_size >= required_size)
				{
					p_left = cast_data_header_32bit(p, p->prev);
					unlink_unused_block(p_left);
					if (unused_right) unlink_unused_block(p_right);
					p_left->size = join_size | prev_busy_bit | busy_bit;
					ptr = cast_data_header(p_left, data_header_offset);
					//copy data to new place
					::memcpy_s(ptr, required_size, cast_data_header(p, data_header_offset), cur_size - data_header_size);
					//split unused block
					split_block(p_left, required_size, cur_size);
					return ptr;
				}
				//force malloc new data block
				ptr = malloc(required_size);
			#if defined(USE_EXTERNAL_ALLOCATOR_ON_FAILURE)
				if (ptr == 0) { ptr = allocator::malloc(required_size); }
			#endif
				if (ptr == 0) { return 0; }
				//copy data to new place
				::memcpy_s(ptr, required_size, cast_data_header(p, data_header_offset), cur_size - data_header_size);
				//release free block back to the pool
				free(cast_data_header(p, data_header_offset));
				return ptr;
			}

		private:
			page_header* _pool_ptr;
			uint32_t     _pool_size;
		};


#undef data_alignment
#undef data_alignment_bits
#undef data_alignment_mask
#undef data_header_size
#undef data_header_bytes
#undef data_header_offset
#undef default_pool_size
#undef busy_bit
#undef prev_busy_bit
#undef fti_bits
#undef fti_first_max
#undef fti_table_n
#undef sti_table_n
#undef page_header_bytes
#undef cast_data_header
#undef cast_data_header_32bit
#undef offs_data_header_32bit
#undef split_block
#undef USE_EXTERNAL_ALLOCATOR_ON_FAILURE
#undef USE_FTI_FIELD_IN_HEADER

#if 0
		//firefox javascript scratchpad
		//for calculation fti_table_n
		var FTI = 5, align = 4, min_size = 16;
		function cl(s, k) { return Math.trunc(s*Math.pow(2, -k))*Math.pow(2, k); }
		var f = function(size)
		{
			if (size < min_size) size = min_size;
			var m = 0, i = 0, fti = Math.trunc(size / align), fti_first_max = 1 << (FTI + 1);
			if (fti >= fti_first_max)
			{
				i = Math.floor(Math.log2(fti)) - FTI;
				//fti = (i<<FTI) + (fti>>i);
				fti = Math.pow(2, FTI)*i + Math.trunc(Math.pow(2, -i)*fti);
			}
			return[cl(size / align, i)*align, (cl(size / align, i) + Math.pow(2, i))*align - 1, fti - min_size / align];
		}
		console.log(f(Math.pow(2, 32)));//2^32 =  4 GB, sli_table_n = 828
		console.log(f(Math.pow(2, 33)));//2^33 =  8 GB, sli_table_n = 860
		console.log(f(Math.pow(2, 34)));//2^34 = 16 GB, sli_table_n = 892
#endif











//bswap for endianess, source: https://github.com/rurban/smhasher/blob/master/t1ha/t1ha_bits.h
#define BSWAP64(v) ((v << 56) | (v >> 56) | ((v << 40) & 0x00ff000000000000ULL) | ((v << 24) & 0x0000ff0000000000ULL) | ((v << 8) & 0x000000ff00000000ULL) | ((v >> 8) & 0x00000000ff000000ULL) | ((v >> 24) & 0x0000000000ff0000ULL) | ((v >> 40) & 0x000000000000ff00ULL))
#define BSWAP32(v) ((v << 24) | (v >> 24) | ((v << 8) & 0x00ff0000UL) | ((v >> 8) & 0x0000ff00UL))
#define BSWAP16(v) (v << 8 | v >> 8)

//unaligned memory access: load don't has huge issues, but store ~ 150 cycles;
//  source https://github.com/dotnet/coreclr/issues/6540



		void MurmurHash3_x86_32(const void* src, const uint32_t len, const uint32_t seed, uint32_t out[1])
		{
			uint32_t i;
			uint32_t k1;
			uint32_t h1 = seed;
			uint32_t c1 = 0xCC9E2D51UL;
			uint32_t c2 = 0x1B873593UL;
			const uint8_t* tail;
			const uint32_t nblocks = len >> 2, *blocks = (const uint32_t*)src;

			for (i = nblocks; i; --i)
			{
				k1 = *blocks++; k1 *= c1; k1 = (k1 << 15) | (k1 >> (32 - 15)); k1 *= c2;
				h1 ^= k1; h1 = (h1 << 13) | (h1 >> (32 - 13)); h1 = h1 * 5 + 0xE6546B64UL;
			}
			tail = (const uint8_t*)blocks;
			k1 = 0;
			switch (len & 3)
			{
			case 3: k1 ^= uint32_t(tail[2]) << 16;
			case 2: k1 ^= uint32_t(tail[1]) << 8;
			case 1: k1 ^= uint32_t(tail[0]);
					k1 *= c1; k1 = (k1 << 15) | (k1 >> (32 - 15)); k1 *= c2; h1 ^= k1;
			};
			//finalization (for incremental update h1 = seed)
			h1 ^= len;
			h1 ^= h1 >> 16; h1 *= 0x85EBCA6BUL; h1 ^= h1 >> 13; h1 *= 0xC2B2AE35UL; h1 ^= h1 >> 16;
			*out = h1;
		}
		//test http://murmurhash.shorelabs.com/
		//0, "111"   => 4084848948
		//0, "hello" => 613153351
		//12,"hello world!" => 3336548647
		//23, "Hello world! I am here!" => 3733080932

		void MurmurHash3_x86_128(const void* src, const uint32_t len, const uint32_t seed, uint32_t out[4])
		{
			uint32_t i;
			uint32_t k1, k2, k3, k4;
			uint32_t h1 = seed, h2 = seed, h3 = seed, h4 = seed;
			uint32_t c1 = 0x239B961BUL;
			uint32_t c2 = 0xAB0E9789UL;
			uint32_t c3 = 0x38B34AE5UL;
			uint32_t c4 = 0xA1E38B93UL;
			const uint8_t* tail;
			const uint32_t nblocks = len >> 4, *blocks = (const uint32_t*)src;

			for (i = nblocks; i; --i)
			{
				k1 = *blocks++; k2 = *blocks++; k3 = *blocks++; k4 = *blocks++;
				k1 *= c1; k1 = (k1 << 15) | (k1 >> (32 - 15)); k1 *= c2; h1 ^= k1;
				h1 = (h1 << 19) | (h1 >> (32 - 19)); h1 += h2; h1 = h1 * 5 + 0x561CCD1BUL;
				k2 *= c2; k2 = (k2 << 16) | (k2 >> (32 - 16)); k2 *= c3; h2 ^= k2;
				h2 = (h2 << 17) | (h2 >> (32 - 17)); h2 += h3; h2 = h2 * 5 + 0x0BCAA747UL;
				k3 *= c3; k3 = (k3 << 17) | (k3 >> (32 - 17)); k3 *= c4; h3 ^= k3;
				h3 = (h3 << 15) | (h3 >> (32 - 15)); h3 += h4; h3 = h3 * 5 + 0x96CD1C35UL;
				k4 *= c4; k4 = (k4 << 18) | (k4 >> (32 - 18)); k4 *= c1; h4 ^= k4;
				h4 = (h4 << 13) | (h4 >> (32 - 13)); h4 += h1; h4 = h4 * 5 + 0x32AC3B17UL;
			}
			tail = (const uint8_t*)blocks;
			k1 = 0; k2 = 0; k3 = 0; k4 = 0;
			switch (len & 15)
			{
			case 15: k4 ^= uint32_t(tail[14]) << 16;
			case 14: k4 ^= uint32_t(tail[13]) << 8;
			case 13: k4 ^= uint32_t(tail[12]) << 0;
					 k4 *= c4; k4 = (k4 << 18) | (k4 >> (32 - 18)); k4 *= c1; h4 ^= k4;
			case 12: k3 ^= uint32_t(tail[11]) << 24;
			case 11: k3 ^= uint32_t(tail[10]) << 16;
			case 10: k3 ^= uint32_t(tail[9]) << 8;
			case  9: k3 ^= uint32_t(tail[8]) << 0;
					 k3 *= c3; k3 = (k3 << 17) | (k3 >> (32 - 17)); k3 *= c4; h3 ^= k3;
			case  8: k2 ^= uint32_t(tail[7]) << 24;
			case  7: k2 ^= uint32_t(tail[6]) << 16;
			case  6: k2 ^= uint32_t(tail[5]) << 8;
			case  5: k2 ^= uint32_t(tail[4]) << 0;
					 k2 *= c2; k2 = (k2 << 16) | (k2 >> (32 - 16)); k2 *= c3; h2 ^= k2;
			case  4: k1 ^= uint32_t(tail[3]) << 24;
			case  3: k1 ^= uint32_t(tail[2]) << 16;
			case  2: k1 ^= uint32_t(tail[1]) << 8;
			case  1: k1 ^= uint32_t(tail[0]) << 0;
					 k1 *= c1; k1 = (k1 << 15) | (k1 >> (32 - 15)); k1 *= c2; h1 ^= k1;
			};
			//finalization (for incremental update h1 = h2 = h3 = h4 = seed)
			h1 ^= len; h2 ^= len; h3 ^= len; h4 ^= len;
			h1 += h2; h1 += h3; h1 += h4;
			h2 += h1; h3 += h1; h4 += h1;
			h1 ^= h1 >> 16; h1 *= 0x85EBCA6BUL; h1 ^= h1 >> 13; h1 *= 0xC2B2AE35UL; h1 ^= h1 >> 16;
			h2 ^= h2 >> 16; h2 *= 0x85EBCA6BUL; h2 ^= h2 >> 13; h2 *= 0xC2B2AE35UL; h2 ^= h2 >> 16;
			h3 ^= h3 >> 16; h3 *= 0x85EBCA6BUL; h3 ^= h3 >> 13; h3 *= 0xC2B2AE35UL; h3 ^= h3 >> 16;
			h4 ^= h4 >> 16; h4 *= 0x85EBCA6BUL; h4 ^= h4 >> 13; h4 *= 0xC2B2AE35UL; h4 ^= h4 >> 16;
			h1 += h2; h1 += h3; h1 += h4;
			h2 += h1; h3 += h1; h4 += h1;
			out[0] = h1; out[1] = h2; out[2] = h3; out[3] = h4;
		}
		//test http://murmurhash.shorelabs.com/
		//12, "hello world!" => {0x74a452de3b195a0c, 0x4fc6b5bc134d03e6}
		//23, "Hello world! I am here!" => {0x70666e8b205aecc7, 0x16a068921c88398e}

		void MurmurHash3_x64_128(const void* src, const uint32_t len, const uint32_t seed, uint64_t out[2])
		{
			uint32_t i;
			uint64_t k1, k2;
			uint64_t h1 = seed, h2 = seed;
			uint64_t c1 = 0x87C37B91114253D5ULL;
			uint64_t c2 = 0x4CF5AD432745937FULL;
			const uint8_t* tail;
			const uint32_t nblocks = len >> 4;
			const uint64_t *blocks = (const uint64_t*)src;

			for (i = nblocks; i; --i)
			{
				k1 = *blocks++; k2 = *blocks++;
				k1 *= c1; k1 = (k1 << 31) | (k1 >> (64 - 31)); k1 *= c2; h1 ^= k1;
				h1 = (h1 << 27) | (h1 >> (64 - 27)); h1 += h2; h1 = h1 * 5 + 0x52DCE729ULL;
				k2 *= c2; k2 = (k2 << 33) | (k2 >> (64 - 33)); k2 *= c1; h2 ^= k2;
				h2 = (h2 << 31) | (h2 >> (64 - 31)); h2 += h1; h2 = h2 * 5 + 0x38495AB5ULL;
			}
			tail = (const uint8_t*)blocks;
			k1 = 0; k2 = 0;
			switch (len & 15)
			{
			case 15: k2 ^= uint64_t(tail[14]) << 48;
			case 14: k2 ^= uint64_t(tail[13]) << 40;
			case 13: k2 ^= uint64_t(tail[12]) << 32;
			case 12: k2 ^= uint64_t(tail[11]) << 24;
			case 11: k2 ^= uint64_t(tail[10]) << 16;
			case 10: k2 ^= uint64_t(tail[9]) << 8;
			case  9: k2 ^= uint64_t(tail[8]) << 0;
					 k2 *= c2; k2 = (k2 << 33) | (k2 >> (64 - 33)); k2 *= c1; h2 ^= k2;
			case  8: k1 ^= uint64_t(tail[7]) << 56;
			case  7: k1 ^= uint64_t(tail[6]) << 48;
			case  6: k1 ^= uint64_t(tail[5]) << 40;
			case  5: k1 ^= uint64_t(tail[4]) << 32;
			case  4: k1 ^= uint64_t(tail[3]) << 24;
			case  3: k1 ^= uint64_t(tail[2]) << 16;
			case  2: k1 ^= uint64_t(tail[1]) << 8;
			case  1: k1 ^= uint64_t(tail[0]) << 0;
					 k1 *= c1; k1 = (k1 << 31) | (k1 >> (64 - 31)); k1 *= c2; h1 ^= k1;
			};
			//finalization (for incremental update h1 = h2 = seed)
			h1 ^= len; h2 ^= len;
			h1 += h2; h2 += h1;
			h1 ^= h1 >> 33; h1 *= 0xFF51AFD7ED558CCDULL; h1 ^= h1 >> 33; h1 *= 0xC4CEB9FE1A85EC53ULL; h1 ^= h1 >> 33;
			h2 ^= h2 >> 33; h2 *= 0xFF51AFD7ED558CCDULL; h2 ^= h2 >> 33; h2 *= 0xC4CEB9FE1A85EC53ULL; h2 ^= h2 >> 33;
			h1 += h2; h2 += h1;
			out[0] = h1; out[1] = h2;
		}
		//test http://murmurhash.shorelabs.com/
		//1,  "hello"        => {0xa78ddff5adae8d10, 0x128900ef20900135}
		//12, "hello world!" => {0xb267716273247be7, 0xcf7c7a126687dac0}
		//23, "Hello world! I am here!" => {0x73c3dd2b5ed2e487, 0x0667416fcbcaad9c}








		//SipHash a fast short-input pseudorandom function family with a 128-bit key and 64 or 128-bit output.
		//SipHash-2-4 for best performance,
		//SipHash-4-8 for conservative security.
		//Source:
		//https://github.com/veorq/SipHash
		//https://github.com/rurban/smhasher (sse)
		//https://github.com/majek/csiphash/blob/master/csiphash.c

#define HALF_ROUND(a,b,c,d,s,t)	\
		a += b; c += d;	\
		b = ((b << s) | (b >> (64 - s))) ^ a; \
		d = ((d << t) | (d >> (64 - t))) ^ c; \
		a = (a << 32) | (a >> (64 - 32));
#define DOUBLE_ROUND(v0,v1,v2,v3)	\
		/* sipround 1 */ \
		HALF_ROUND(v0,v1,v2,v3,13,16);	\
		HALF_ROUND(v2,v1,v0,v3,17,21);	\
		/* sipround 2 */ \
		HALF_ROUND(v0,v1,v2,v3,13,16);	\
		HALF_ROUND(v2,v1,v0,v3,17,21);	\

		// siphash-2-4, 128 bit key, 64 bit output
		void siphash24_64(const void *src, uint32_t len, const uint64_t key[2], uint64_t out[1])
		{
			uint64_t
				t,
				k0 = key[0], k1 = key[1],
				b = ((uint64_t)(len & 0xFF)) << 56,
				v0 = k0 ^ 0x736F6D6570736575ULL,
				v1 = k1 ^ 0x646F72616E646F6DULL,
				v2 = k0 ^ 0x6C7967656E657261ULL,
				v3 = k1 ^ 0x7465646279746573ULL;

			uint64_t *in = (uint64_t*)src;
			for (;len >= 8;len -= 8)
			{
				t = *in++;
				v3 ^= t;
				DOUBLE_ROUND(v0, v1, v2, v3); //c = 2 rounds
				v0 ^= t;
			}
			t = 0; uint8_t *m = (uint8_t*)in;
			switch (len)
			{
			case 7: t |= ((uint64_t)m[6]) << 48;
			case 6: t |= ((uint64_t)m[5]) << 40;
			case 5: t |= ((uint64_t)m[4]) << 32;
			case 4: t |= ((uint64_t)m[3]) << 24;
			case 3: t |= ((uint64_t)m[2]) << 16;
			case 2: t |= ((uint64_t)m[1]) << 8;
			case 1: t |= ((uint64_t)m[0]);
			}
			t |= b;
			v3 ^= t;
			DOUBLE_ROUND(v0, v1, v2, v3); //c = 2 rounds
			v0 ^= t;
			v2 ^= 0xFF;
			DOUBLE_ROUND(v0, v1, v2, v3); DOUBLE_ROUND(v0, v1, v2, v3); //d = 4 rounds
			*out = v0 ^ v1 ^ v2 ^ v3;
		}
		//test
		//key = "1234567812345678",                      "hello world!" => 0x53bedbebc8d5bb58
		//key = {0x0706050403020100,0x0f0e0d0c0b0a0908}, "hello world!" => 0x83b187ce51e5332d

		// siphash-2-4, 128 bit key, 128 bit output
		void siphash24_128(const void *src, uint32_t len, const uint64_t key[2], uint64_t out[2])
		{
			uint64_t
				t,
				k0 = key[0], k1 = key[1],
				b = ((uint64_t)(len & 0xFF)) << 56,
				v0 = k0 ^ 0x736F6D6570736575ULL,
				v1 = k1 ^ 0x646F72616E646F83ULL,
				v2 = k0 ^ 0x6C7967656E657261ULL,
				v3 = k1 ^ 0x7465646279746573ULL;

			uint64_t *in = (uint64_t*)src;
			for (;len >= 8;len -= 8)
			{
				t = *in++;
				v3 ^= t;
				DOUBLE_ROUND(v0, v1, v2, v3); //c = 2 rounds
				v0 ^= t;
			}
			t = 0; uint8_t *m = (uint8_t*)in;
			switch (len)
			{
			case 7: t |= ((uint64_t)m[6]) << 48;
			case 6: t |= ((uint64_t)m[5]) << 40;
			case 5: t |= ((uint64_t)m[4]) << 32;
			case 4: t |= ((uint64_t)m[3]) << 24;
			case 3: t |= ((uint64_t)m[2]) << 16;
			case 2: t |= ((uint64_t)m[1]) << 8;
			case 1: t |= ((uint64_t)m[0]);
			}
			t |= b;
			v3 ^= t;
			DOUBLE_ROUND(v0, v1, v2, v3); //c = 2 rounds
			v0 ^= t;
			v2 ^= 0xEE;
			DOUBLE_ROUND(v0, v1, v2, v3); DOUBLE_ROUND(v0, v1, v2, v3); //d = 4 rounds
			out[0] = v0 ^ v1 ^ v2 ^ v3; //store first 64 bit
			v1 ^= 0xDD;
			DOUBLE_ROUND(v0, v1, v2, v3); DOUBLE_ROUND(v0, v1, v2, v3); //d = 4 rounds
			out[1] = v0 ^ v1 ^ v2 ^ v3; //store second 64 bit
		}
		//test
		//key = {0x0706050403020100,0x0f0e0d0c0b0a0908}, "hello world!" => {0x0357d28cd7973d91, 0x4457c7c13ac02a00}

#undef HALF_ROUND
#undef DOUBLE_ROUND







	}//end namespace memory
}//end namespace LZ - lazy
